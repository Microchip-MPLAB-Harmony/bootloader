var SearchFiles = ["GUID-21B27208-104A-468D-8F94-F58D432AB08C.html",
							"GUID-7EF4113C-BB31-47A2-96E8-2965EC312340.html",
							"GUID-03E67D01-3442-4A5E-A1D7-8C5EF776D876.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-C2AA810E-4247-4971-99CA-8F3D78A9DD2F.html",
							"GUID-A6CA4BD5-4F43-4E12-8624-3AA1328B3DFE.html",
							"GUID-CFBAB2D2-47E5-4A1D-AD31-BBCA6C7FC3A9.html",
							"GUID-8828D474-F227-4FE0-88EE-135AA591750F.html",
							"GUID-C34FDEFB-E3B0-4C31-9702-E3C457A1B6C7.html",
							"GUID-171634E3-4F7B-4CBD-BCE9-EC2BB22BF2AD.html",
							"GUID-4383C8ED-D221-41F6-9B6C-1B70FF3B18A2.html",
							"GUID-02519565-B72E-496D-8153-E00F011D9130.html",
							"GUID-F222E4C9-8DCD-4917-A147-2EABBE9969F1.html",
							"GUID-90F92E3B-7EB3-4EF6-8A48-81D660ED6A12.html",
							"GUID-7E38E7D5-AB6E-4C67-A6E6-7F3BA58FDEF3.html",
							"GUID-81FF31CA-1770-4876-8AAB-FA0015038359.html",
							"GUID-74A00B0A-18C1-47BD-A5F7-5BAFEDDAD130.html",
							"GUID-08918A90-608F-49D9-A966-E5FB1BF0ABF0.html",
							"GUID-E2DB2D26-B73B-4C24-A7C2-0574FAEE0C29.html",
							"GUID-3C3BD693-4F3C-46C4-B4FC-517A4BA1DEFA.html",
							"GUID-145B7BD5-2EBD-4A08-8574-BE3103D234C9.html",
							"GUID-52D245E1-C639-46E3-97B2-EB864CECF0B2.html",
							"GUID-8453780B-E7F1-4D9F-8609-DD333F154CC7.html",
							"GUID-873813A9-C0F5-477D-A1A9-E25CDA9598DD.html",
							"GUID-8BE0388C-8563-4ED8-9C17-F3FE7B88FE51.html",
							"GUID-FB2B5DA3-4F99-405D-8D3B-C622B8D029B4.html",
							"GUID-05CA35ED-C84A-4F88-AAC1-F37D8F6EFEF4.html",
							"GUID-1F89A7A4-5442-43F8-B18C-F271503712B9.html",
							"GUID-E3F876E5-BE9E-426E-8DC4-E03EF71E8605.html",
							"GUID-DAABEA91-BE58-400D-B1FE-1808457896A8.html",
							"GUID-EFEE222D-BE1D-42F5-A032-C966B5DA09C2.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-3942704D-13D2-4E8E-A9DC-4055E7F6D5AB.html",
							"GUID-0F69B7CD-9FC1-43EC-BFBB-B52B8FBAFE9E.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-61DDF8DF-119C-4515-A818-68C933260DB9.html",
							"GUID-B9D22739-DB16-4626-A5E8-05C5DCB1C8DD.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-DC31D773-75F7-482A-91FF-204681625DA3.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-FCD04D38-6A0B-4B16-ABC6-33AC5EE0C561.html",
							"GUID-30D6292F-AE16-4444-A68B-BC8BC5000A63.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-67381576-E9AA-4E3C-BE36-D32966B8E034.html",
							"GUID-13849322-051C-4B2E-9CD0-632F6D89DDB0.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-1A9B682E-0E06-44BE-AE0B-B9816F9D8ABF.html",
							"GUID-58FF7035-084F-4CDE-A151-818752F0DCF2.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-ECD677F9-D618-4232-8A1E-9C488FE07E6E.html",
							"GUID-94FBDB48-98DC-4C4B-861D-9327D7076ADE.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-39A587F3-01B0-40CD-BF7E-3F23871BE462.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-AC20F067-9388-42CD-A49D-05496869CC4D.html",
							"GUID-7AD52CC2-469F-4BD3-B979-52AF12BE34FA.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-A0B4A3D8-1681-4774-AF4E-2F076263772A.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-1FC4D617-90BB-496E-9BDC-A7D91BC7BBA2.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-26BD4D0B-9547-4AD1-A013-94DCFFC90933.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-EEB0BC77-4006-44EF-8E7F-A9B4D5948189.html",
							"GUID-BFB2EC03-1B79-42F8-A77F-26CCCEA0312C.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-6AFE1F49-ABB7-45E3-B783-95058156850B.html",
							"GUID-FE2D4DDB-3A4B-4304-A86D-0A227017B23D.html",
							"GUID-9D8745A3-BF8B-4B77-B2B0-D0322693C210.html",
							"GUID-B1F2D637-5936-4FD2-BA57-9AEABCB58A3A.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-669D82E9-C939-4D99-A85C-1898495A568B.html",
							"GUID-C9AE7919-7F70-4915-B12C-72F6F449C1D2.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-B0B0B2AC-6B17-43C1-B801-46E9639B3E66.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-B846B0DE-5963-48AC-B030-9767E38A82DB.html",
							"GUID-8D4C947B-BA9B-4C1B-AF7A-209A4FC78662.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-C2D4E98A-C367-48ED-9079-5AC48374542D.html",
							"GUID-E5F8EA96-492F-42CA-8D42-746D091955AD.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-4B1469D8-2DAF-46D9-85B4-31895F8645A9.html",
							"GUID-4B1469D8-2DAF-46D9-85B4-31895F8645A9.html",
							"GUID-4B1469D8-2DAF-46D9-85B4-31895F8645A9.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-287956CB-1611-412A-955C-6B85F8BA3916.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-1A9282A3-358C-4218-9A8A-CE8492B06164.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-B4EA3FC1-6EDC-409B-B973-1E2B5B9DA982.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-B40F9A07-D16A-42CF-8121-B52B5BDD7685.html",
							"GUID-90369DFF-8F80-4CB1-9536-FD4A4EA4B0DD.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-BF0771C3-3A36-4B29-9CD4-E9D7F6EC193F.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-9C85926E-D680-48D7-B64A-64F52BF64766.html",
							"GUID-D70E2C74-59C6-4741-9FCA-CD7EBF5AED80.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-7325E59D-D429-4305-9AFC-5BE10EE38EE2.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-7E38E7D5-AB6E-4C67-A6E6-7F3BA58FDEF3.html",
							"GUID-2A66A563-5A79-49DA-AE0F-90CA19F807EA.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-7E38E7D5-AB6E-4C67-A6E6-7F3BA58FDEF3.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-A1E794F4-0659-4283-AF6A-3642708A0F7D.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html",
							"GUID-8DC24BD7-3112-401A-A207-3A1FC3A416AB.html"];

var SearchTitles = ["MPLAB® Harmony Bootloader Library",
"UART Bootloader",
"How the UART Bootloader library works",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for MIPS based MCUs",
"Fail Safe Update Memory layout for CORTEX-M based MCUs",
"Fail Safe Update Memory layout for MIPS based MCUs",
"UART Bootloader Protocol",
"UART Bootloader system level execution flow",
"Bootloader Trigger Methods",
"UART Bootloader Firmware Update mode execution flow",
"UART Bootloader Configurations",
"Bootloader linker configurations for MIPS based MCUs",
"Bootloader linker configurations for CORTEX-M based MCUs",
"Bootloader Sizing And Considerations",
"Configurations for the application to be bootloaded",
"Application project configurations for CORTEX-M based MCUs",
"Application project configurations for MIPS based MCUs",
"Application linker configurations for MIPS based MCUs",
"UART Bootloader Library Interface",
"bootloader_Tasks Function",
"bootloader_Trigger Function",
"run_Application Function",
"bootloader_ProgramFlashBankSelect Function",
"UART Bootloader Host Script Help",
"Bootloader and Application binary merge script Help",
"Debugging Bootloader and Application to be bootloaded",
"Debugging UART I2C and CAN Bootloaders for CORTEX-M based MCUs",
"Debugging Bootloader and Application to be bootloaded",
"I2C Bootloader",
"How the I2C Bootloader library works",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"I2C Bootloader Protocol",
"I2C Bootloader system level execution flow",
"Basic Memory layout for CORTEX-M based MCUs",
"I2C Bootloader Firmware Update mode execution flow",
"I2C Bootloader Configurations",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"I2C Bootloader Library Interface",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"I2C/CAN Bootloader Tools Help",
"Binary to C Array script help",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"CAN Bootloader",
"How the CAN Bootloader library works",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"CAN Bootloader Protocol",
"CAN Bootloader system level execution flow",
"Basic Memory layout for CORTEX-M based MCUs",
"CAN Bootloader Firmware Update mode execution flow",
"CAN Bootloader Configurations",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"CAN Bootloader Library Interface",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Serial Memory Bootloader",
"How the Serial Memory Bootloader library works",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Serial Memory Bootloader execution flow",
"Basic Memory layout for CORTEX-M based MCUs",
"Serial Memory Bootloader Configurations",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Serial Memory Bootloader Library Interface",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"USB Device HID Bootloader",
"How the USB Device HID Bootloader library works",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Live Update Memory layout for CORTEX-M based MCUs",
"Live Update Memory layout for MIPS based MCUs",
"USB Device HID Bootloader Protocol",
"Bootloader system level execution flow",
"Basic Memory layout for CORTEX-M based MCUs",
"USB/UDP Firmware Update mode execution flow",
"USB Device HID Bootloader Configurations",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"USB Device HID Bootloader Library Interface",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"bootloader_SwapAndReset Function",
"USB Device HID Bootloader Unified Host Script Help",
"Basic Memory layout for CORTEX-M based MCUs",
"UDP Bootloader",
"How the UDP Bootloader library works",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"UDP Bootloader Protocol",
"Read CRC (Currently Not Supported)",
"Jump to Application",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"UDP Bootloader Configurations",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"UDP Bootloader Library Interface",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"UDP Bootloader Unified Host Script Help",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"File System Bootloader",
"How the File System Bootloader library works",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"File System Bootloader system level execution flow",
"Basic Memory layout for CORTEX-M based MCUs",
"File System Bootloader Firmware Update mode execution flow",
"USB Host MSD Bootloader Configurations",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"SD Card Bootloader Configurations",
"Basic Memory layout for CORTEX-M based MCUs",
"Bootloader Sizing And Considerations",
"Serial Memory Bootloader Configurations",
"Basic Memory layout for CORTEX-M based MCUs",
"Bootloader Sizing And Considerations",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"File System Bootloader Library Interface",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs",
"Basic Memory layout for CORTEX-M based MCUs"];

var SearchInfo = [" MPLAB® Harmony Bootloader Library The Bootloader Library can be used to upgrade firmware on a target device without the need for an external programmer or debugger A Bootloader is a small application that starts the operation of the device A Bootloader does not fully operate the device but can perform various functions prior to starting the main application Such functions can include: Firmware upgrades Application integrity Starting the application Supported Bootloaders Bootloader Description UART This section provides help on the Optimized UART Bootloader library I2C This section provides help on the Optimized I2C Bootloader library CAN This section provides help on the Optimized CAN Bootloader library Serial Memory This section provides help on the Serial Memory Bootloader library USB Device HID This section provides help on the USB Device HID Bootloader library UDP This section provides help on the UDP Bootloader library File System This section provides help on the File system Bootloader library ",
							" UART Bootloader The UART bootloader Library can be used to upgrade firmware on a target device without the need for an external programmer or debugger Features Supported on CORTEX-M and MIPS based MCUs Uses Harmony 3 UART PLIB to communicate resulting in smaller bootloader size Supports Fail Safe update Takes Binary File as input Uses command line host script to receive binary from Host PC Running From SRAM (For SAM Devices) Supports simultaneous Flash memory write and reception of the next block of data Achieved by loading bootloader into flash and running from SRAM Has capability to self update as it is running from SRAM bootloader_ram_layout At reset the bootloader Reset handler copies the entire bootloader firmware into SRAM from Start location and start executing from SRAM Once the application is called from bootloader applications startup code takes control over SRAM and starts executing UART Bootloader Block Diagram uart_bootloader_block_diagram Input Task: This task is responsible for receiving data from Embedded Host through the UART communication interface The task keeps polling for data to be received when bootloader is in idle mode The task also validates the incoming packet from host with expected header information Once the packet reception is completed it gives control to Command Task Command Task: This task processes the commands received from Input Task and provides response back to host accordingly If the command received is a Data command it gives control to the Flash Task Flash Task: This task is responsible to program the internal flash memory with data packet received The task uses the NVM peripheral library to perform the Unlock/Erase/Write Operations The task also invokes Input Task in parallel to receive next packet while waiting for the flash operation to complete for CORTEX-M based MCUs ",
							" How the UART Bootloader library works The UART Bootloader firmware communicates with the personal computer host application by using a predefined communication protocol The UART Bootloader works in two different modes Basic Mode This mode is supported for all the devices Resides from The starting location of the flash memory region for CORTEX-M based MCUs The starting location of the Boot flash memory region for MIPS based MCUs devices The Bootloader performs flash erase/program/verify operations with the binary sent from host while in the firmware upgrade mode The binary sent is only of the application to be programmed Bootloader always performs flash operation from the address for (bootloader or application) binary sent from host The application can use the entire flash memory region starting from the end of bootloader space Jumps to the application once verification is completed Fail Safe Update Mode This mode is supported for the devices which have a Dual Bank flash memory Resides from the starting location of the flash memory region of both the banks on CORTEX-M based MCUs The Bootloader performs flash erase/program/verify operations with the binary sent from host while in the firmware upgrade mode Bootloader can perform flash operation in either of the banks based on the address sent by the host application The application can use only the flash memory region of one bank Performs a bank swap and reset to run the application programmed in inactive bank once verification is completed or a normal reset to run the application in current bank based on command sent from host ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for MIPS based MCUs Bootloader placement for various PIC32M product families The bootloader is placed in Boot Flash Memory (BFM) or Program Flash Memory (PFM) based on the size of the bootloader and available Boot flash memory on the device If the bootloader fits into the available BFM it is placed in BFM The user application can use the complete area of the program Flash memory If the bootloader does not fit into the available BFM its reset handler is placed in BFM and rest of code is placed in PFM The user application can use the remaining area of the program Flash memory The following table shows the available Boot Flash memory and the placement of different bootloaders by product family Note: The Boot Flash and Program Flash memory end addresses may vary from device to device Refer to respective Data sheets for details of Flash memory layout bootloader_placement Basic Memory layout mips_basic_memory_layout ",
							" Fail Safe Update Memory layout for CORTEX-M based MCUs Supported for the devices which have a Dual Bank flash memory Internal Flash memory is split into two equal banks Special NVM Fuse setting (AFIRST) is used to identify which bank is mapped to NVM main address space after reset Start address of Active Bank is always start of Internal Flash memory Start address of Inactive Bank is from mid of the Internal flash memory which can vary from device to device Refer to respective Data sheets for details of Flash memory layout Bootloader must be placed at start location of both banks The application code can be placed anywhere after the bootloader end address till mid of flash The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Bootloader running from Active bank will program the new image in inactive bank Bootloader is responsible to perform a bank swap and reset to run the new firmware programmed in Inactive bank arm_fail_safe_update_memory_layout ] ",
							" Fail Safe Update Memory layout for MIPS based MCUs Bootloader placement for various PIC32M product families The bootloader is placed in Boot Flash Memory (BFM) or Program Flash Memory (PFM) based on the size of the bootloader and available Boot flash memory on the device If the bootloader fits into the available BFM it is placed in BFM The user application can use the complete area of the program Flash memory If the bootloader does not fit into the available BFM its reset handler is placed in BFM and rest of code is placed in PFM The user application can use the remaining area of the program Flash memory The following table shows the available Boot Flash memory and the placement of different bootloaders by product family Note: The Boot Flash and Program Flash memory end addresses may vary from device to device Refer to respective Data sheets for details of Flash memory layout bootloader_placement Fail Safe Update layout Supported for the devices which have a Dual Bank flash memory Bootloader code is placed at start of the Boot flash memory (0xBFC00000) as upon reset the device runs from start of boot flash memory Device always executes the application firmware from PFM bank mapped to lower memory region (0x1D00_0000 Physical address) Start address of Active Bank is mapped to lower region 0x9D000000 Start address of Inactive Bank is from mid of the PFM which can vary from device to device Refer to respective Data sheets for details of Flash memory layout Row size number of bytes are reserved at end of each bank for storing serial number This serial number will be used by the bootloader code placed in BFM to map the appropriate PFM bank to lower memory region and run the application from there Volatile register SWAP bit is used to map either of bank to lower memory region by bootloader When Bootloader is running it will program the new image in the inactive bank and performs below operation and initiates a reset Inactive Serial number = Active serial number + 1 At reset bootloader first maps Bank 1 to lower region and reads the serial numbers from both banks If Bank 2 serial number is greater than Bank 1 serial number it maps Bank 2 to lower region by setting the Swap bit and runs the new firmware Now Bank 2 is Active bank The application start address should always fall into lower mapped region (0x9D000000 to Mid of Flash) Size of the application in the linker script should also not exceed the Mid of flash The address passed to bootloader during programming should fall either in active bank or inactive bank based on update being done mips_fail_safe_update_memory_layout ",
							" UART Bootloader Protocol Request Packet The uart bootloader protocol as shown in below figure is common for all the supported commands uart_bootloader_protocol GUARD The Guard value must be a constant value of 0x5048434D This value provides protection against spurious commands Bootloader always checks for the Guard value at start of packet reception and proceeds further accordingly Data Size This field indicates the number of data bytes to be received This value varies for different commands Command Indicates the command to be processed Each command is of 1 Byte width Below are the supported commands Command Type Command Code Description Unlock 0xA0 Used to calculate application start address and end address Data 0xA1 Used to send the image data Verify 0xA2 Used to verify the image data sent and programmed Reset 0xA3 Used to trigger a reset to run the application Bank Swap and reset 0xA4 Used to Swap the bank and trigger a reset to run the application Data Contains the actual Data to be processed based on the command Length of the data to be received is indicated by Data Size field Bootloader receives data in size of words All data words must be sent in a little-endian (LSB first) format Response Codes Bootloader will send a single character response code in response to each command Sequential commands can only be sent after the response code is received for a previous command or after 100 ms timeout without a response Response Type Response Code Description OK 0x50 Command was received and processed successfully Error 0x51 There were errors during the processing of the command Invalid 0x52 Invalid command is received CRC OK 0x53 CRC verification was successful CRC Fail 0x54 CRC verification failed Command Description Unlock Command The Unlock Command sequence is as shown in below figure with corresponding responses uart_bootloader_unlock_command Unlock command must be issued before the first Data command It is used to calculate application start address and end address This information will be used to validate if the addresses sent are within the range of flash memory It will also be used to validate the address coming with data packet to be programmed are within the region for which the unlock command is invoked Number of bytes of data to be received is 8 Bytes (Start Address + Image Size) Start Address It is the application Start Address of the flash memory It is device dependent and should be always greater than or equal to the bootloader end address It must be aligned at an Erase Unit Size boundary which is also device dependent To upgrade the bootloader itself this value must be set to 0 (For CORTEX-M based MCUs) Image size must be in increments of Erase Unit bytes which is also device dependent Data Command The Data Command sequence is as shown in below figure with corresponding responses uart_bootloader_data_command Data command is used to send the image data Data size is equal to sum of block start address (4 Bytes) and Erase Unit Size which is device dependent Block start address must be located inside the region previously unlocked via the Unlock command Attempts to request the write outside of the unlocked region will result in error and supplied data will be discarded Verify Command The Verify Command sequence is as shown in below figure with corresponding responses uart_bootloader_verify_command Verify command is used to verify the image data sent and programmed Image CRC is a standard IEEE CRC32 with a polynomial of 0xEDB88320 Internal CRC is calculated based on the values actually read from the Flash memory after programming so it verifies the whole chain Image CRC is calculated over the previously unlocked region Reset Command The Reset Command sequence is as shown in below figure with corresponding responses uart_bootloader_reset_command Reset command is used to exit the bootloader and run the application It is necessary if the host has no control over the reset pin It can also be useful even if host has control over the Reset Bank Swap and Reset Command The Bank Swap and Reset Command sequence is as shown in below figure with corresponding responses uart_bootloader_BankSwap_Reset_command This command is enabled only when Fail safe update feature is selected for bootloader and the device has support for Dual Bank update Bank Swap and Reset command is used to Swap the inactive bank to active bank and trigger a reset to exit the bootloader and run the new application programmed in the inactive bank Note: As this bootloader supports simultaneous Flash memory write and reception of the next block of data The next block of data may be transmitted as soon as the status code is returned for the first one Because of this behavior the status code for the last block will be sent before this block is written into the Flash memory To ensure that this block is written host must send another command and wait for the response So either Verify or Reset command must be sent after the last block of data ",
							" UART Bootloader system level execution flow Basic Bootloader system level execution flow The Bootloader code starts executing on a device Reset If there are no conditions to enter the firmware upgrade mode the Bootloader starts executing the user application Refer to Bootloader Trigger Methods for different conditions to enter firmware upgrade mode The Bootloader performs Flash erase/program operations while in the firmware upgrade mode basic_bootloader_execution_flow Fail Safe Update Bootloader system level execution flow (MIPS Based MCUs) Bootloader always maps Bank 1 to lower region at boot up irrespective of cause for reset (Hard/Soft)  This is required because if Swap bit was set and a soft reset was triggered the value is retained but if Swap bit was set and Hard reset was triggered the value is cleared Once Swap bit is cleared and Bank 1 is mapped to lower region it performs below operation If Bank 1 serial number is greater than Bank 2 serial number it just continues for trigger check or runs application from Bank 1 As Bank 1 is already mapped to lower region in above step (Bank 1 is Active Bank) If Bank 2 serial number is greater than Bank 1 serial number it maps Bank 2 to lower region by setting the Swap bit and proceeds to trigger check or runs application from Bank 2 (Bank 2 is Active Bank) Whenever Bootlader programs new application in the Inactive bank and swap bank command is received it reads the serial number from Active bank increments by 1 and then writes to Inactive Bank serial Inactive Bank Serial number = Active Bank serial number + 1 Start address of inactive bank is equal start of mid of flash If the Host application requests to update the Active Bank and the address falls into the active bank serial sector it sends an error response and aborts the programming operation fail_safe_update_bootloader_execution_flow_mips ",
							" Bootloader Trigger Methods Bootloader can be invoked in number of ways: - Bootloader will run automatically if there is no valid application firmware - Firmware is considered valid if the first word at application start address is not 0xFFFFFFFF - Normally this word contains initial stack pointer value so it will never be **0xFFFFFFFF** unless device is erased Bootloader application can implement the bootloader_Trigger() function which will be called during system initialization A GPIO pin can be used as an external trigger to invoke bootloader at startup Bootloader can run on application (internal) request if the configured number of bytes from start of SRAM are equal to some trigger pattern Example Implementation of bootloader_Trigger() # define BTL_TRIGGER_PATTERN 0x5048434D  static uint32_t * ramStart =  ( uint32_t * ) BTL_TRIGGER_RAM_START ; bool bootloader_Trigger ( void )  {  /* Check for Bootloader Trigger Pattern in first 16 Bytes of RAM to enter * Bootloader */  if  ( BTL_TRIGGER_PATTERN == ramStart [ 0 ]   BTL_TRIGGER_PATTERN == ramStart [ 1 ]   BTL_TRIGGER_PATTERN == ramStart [ 2 ]   BTL_TRIGGER_PATTERN == ramStart [ 3 ] )  { ramStart [ 0 ]  =  0 ;  return true ;  }  /* Check for Switch press to enter Bootloader */  if  ( SWITCH_Get ( )  ==  0 )  {  return true ;  }  return false ;  }  Application code to trigger bootloader void  invoke_bootloader ( void )  { uint32_t * sram =  ( uint32_t * ) BTL_TRIGGER_RAM_START ; sram [ 0 ]  =  0x5048434D ; sram [ 1 ]  =  0x5048434D ; sram [ 2 ]  =  0x5048434D ; sram [ 3 ]  =  0x5048434D ;  NVIC_SystemReset ( ) ;  }  ",
							" UART Bootloader Firmware Update mode execution flow Bootloader Task Flow Bootloader task is the main task which calls the 3 sub-tasks in a forever loop It always calls the Input task to poll for command packets from host Once complete packet is received it calls Command task to process the received command If the command received was a data command it calls programming task to flash the application uart_bootloader_task_execution_flow Input Task Flow This task is used to receive the data bytes from host PC If there are valid GUARD bytes received at start of packet it proceeds further to receive the whole packet or else reports error and waits for next command All bytes of the command frame must be sent within 100 ms of each other After 100 ms of idle time incomplete command is discarded and bootloader goes back to waiting for a new Command This behavior allows host to re-synchronize in the case of synchronization loss uart_input_task_execution_flow Command Task Flow This task processes the packet received for supported commands If the received command is a DATA command it sets ready_to_flash flag so that the bootloader task can call Flash task uart_command_task_execution_flow Flash Task Flow This task performs flash operations on the received data For CORTEX-M based MCUs As the bootloader is running from RAM While waiting for flash operations to complete it calls Input task to receive the next command in parallel uart_flash_task_execution_flow_sam For MIPS based MCUs uart_flash_task_execution_flow_pic32m ",
							" UART Bootloader Configurations Bootloader Specific User Configurations For CORTEX-M based MCUs uart_bootloader_mhc_config_sam For MIPS based MCUs uart_bootloader_mhc_config_pic32m Bootloader Peripheral Used: Specifies the communication peripheral used by bootloader to receive the application The name of the peripheral will vary from device to device Bootloader NVM Memory Used: Specifies the memory peripheral used by bootloader to perform flash operations The name of the peripheral will vary from device to device Bootloader Size (Bytes): Specifies the maximum size of flash required by the bootloader This size is calculated based on Bootloader type and Memory used This size will vary from device to device and should always be aligned to device erase unit size Enable Bootloader Trigger From Firmware: This Option can be used to Force Trigger bootloader from application firmware after a soft reset It does so by reserving the specified number of bytes in SRAM from the start of the RAM The reserved memory is updated by the application with a pre-defined pattern The bootloader firmware in the bootloader_Trigger() routine can check the reserved memory for the pre-defined pattern and enter bootloader mode if the pattern matches Number Of Bytes To Reserve From Start Of RAM: This option adds the provided offset to RAM Start address in bootloader linker script Application firmware can store some pattern in the reserved bytes region from RAM start for bootloader to check at reset in bootloader_Trigger() function Use Dual Bank For Safe Flash Update: Used to configure bootloader to use Dual banks of device to upload the application This option is visible only for devices supporting Dual flash banks Bootloader System Configurations uart_bootloader_mhc_config_system Application Start Address (Hex): Start address of the application which will programmed by bootloader This value is filled by bootloader when its loaded which is equal to the bootloader size It can be modified as per user need This value will be used by bootloader to Jump to application at device reset Note For optimizing the code Bootloader component disables generation of default interrupt and exception files as shown below Enabling these interrupts explicitly may still not work as bootloader uses custom startup file which has its own Interrupt table populating only the reset handler uart_bootloader_mhc_config_interrupt_disable ",
							" Bootloader linker configurations for MIPS based MCUs Bootloader placement for various PIC32M product families The bootloader is placed in Boot Flash Memory (BFM) or Program Flash Memory (PFM) based on the size of the bootloader and available Boot flash memory on the device If the bootloader fits into the available BFM it is placed in BFM The user application can use the complete area of the program Flash memory If the bootloader does not fit into the available BFM it is placed in PFM The user application can use the remaining area of the program Flash memory The following table shows the available Boot Flash memory and the placement of different bootloaders by product family bootloader_placement Bootloader linker script settings Bootloader library uses a custom linker script which is generated through MHC The values populated in the linker script are based on the Bootloader component MHC configurations The vector address of a given interrupt is calculated using Exception Base (EBASE) CPU register and the _ebase_address should be aligned to 4KB boundary Note: The below sections provides overview of changes done to bootloader linker scripts when compared to default linker script The address location and size may vary based on the specific device used For Bootloaders placed in Boot Flash Memory (PIC32MZ and PIC32MK Devices) The bootloader start address by default will be start of Boot flash memory (0xBFC00000) This is the default startup location for all PIC32M devices The Initial 4KB from Bootloader start address are used by Reset Handler and cache_init section followed by rest of bootloader code Length of the bootloader is calculated based on the bootloader being added to MHC XC32 Compiler calculates offset from the EBASE address and initializes the value of interrupt vector offset (OFFx) register The offset register is combined with EBASE register using a bitwise OR operator to obtain the interrupt vector address that the CPU will jump to when the corresponding interrupt occurs If the EBASE address is aligned to 4KB then all the interrupt vectors must be located within the 4KB from base address Example: When _ebase_address is set to 0x9FC01000 and interrupts vectors are not located withing the 4KB boundary from the ebase address (OFFx 0x1000) then the bitwise OR operator may not provide correct interrupt vector address To provide maximum flexibility in placement of interrupt vectors: The _ebase_address is placed at start of Boot flash memory (0x9FC00000) Offsets of exceptions and vector sections are updated to place them after the device startup code With this the interrupt handlers can be located anywhere in the Boot Flash memory Generated linker scripts as explained above is shown here as an example Bootloader length bootloader_length in the below snippet is auto generated based on the bootloader component added in MHC Note: Cache related sections are not applicable for PIC32MK Devices PROVIDE ( _vector_spacing =  0x0001 ) ;  PROVIDE ( _ebase_address =  0x9FC00000 ) ;  /* Place the vector table and other exceptions after the device reset and * cache init code */  PROVIDE ( _ebase_vector_offsets =  0x1000 ) ; _RESET_ADDR =  0xBFC00000 ; _BEV_EXCPT_ADDR =  0xBFC00380 ; _DBG_EXCPT_ADDR =  0xBFC00480 ; _SIMPLE_TLB_REFILL_EXCPT_ADDR = _ebase_address + _ebase_vector_offsets +  0 ; _CACHE_ERR_EXCPT_ADDR = _ebase_address + _ebase_vector_offsets +  0x100 ; _GEN_EXCPT_ADDR = _ebase_address + _ebase_vector_offsets +  0x180 ; kseg0_program_mem ( rx )  : ORIGIN =  0x9FC01000  LENGTH =   bootloader_length  kseg1_boot_mem : ORIGIN =  0xBFC00000  LENGTH =  0x480 kseg1_boot_mem_4B0 : ORIGIN =  0xBFC004B0  LENGTH =  0x1000  -  0x4B0     config_BFC0FF40 : ORIGIN =  0xBFC0FF40  LENGTH =  0x4 config_BFC0FF44 : ORIGIN =  0xBFC0FF44  LENGTH =  0x4 config_BFC0FF48 : ORIGIN =  0xBFC0FF48  LENGTH =  0x4         SECTIONS {   config_BFC0FF40 :  {  KEEP ( * (  config_BFC0FF40 ) )  }   config_BFC0FF40  config_BFC0FF44 :  {  KEEP ( * (  config_BFC0FF44 ) )  }   config_BFC0FF44         }  /* Boot Sections */   reset _RESET_ADDR :  {  KEEP ( * (  reset ) )  KEEP ( * (  reset  startup ) )  }   kseg1_boot_mem  cache_init :  {  * (  cache_init )  * (  cache_init  * )  }   kseg1_boot_mem_4B0     /* Interrupt vector table with vector offsets */   vectors _ebase_address + _ebase_vector_offsets +  0x200  :  {  /* Symbol __vector_offset_n points to vector_n if it exists * otherwise points to the default handler The * vector_offset_init o module then provides a data section * containing values used to initialize the vector-offset SFRs * in the crt0 startup code */    =  ALIGN ( 4 )  ; __vector_offset_0 =  ( DEFINED ( __vector_dispatch_0 )    (   - _ebase_address )  : __vector_offset_default ) ;  KEEP ( * (  vector_0 ) )          /* Default interrupt handler */    =  ALIGN ( 4 )  ; __vector_offset_default =    - _ebase_address ;  KEEP ( * (  vector_default ) )  }   kseg0_program_mem For Bootloaders placed in Program Flash Memory (PIC32MK Devices) The bootloader start address by default will be start of Boot flash memory (0xBFC00000) This is the default startup location for all PIC32M devices As the entire bootloader cannot be placed in BFM Only the bootloader Reset Handler is placed in BFM Rest of the bootloader code will be placed from start of Program Flash memory XC32 Compiler calculates offset from the EBASE address and initializes the value of interrupt vector offset (OFFx) register The offset register is combined with EBASE register using a bitwise OR operator to obtain the interrupt vector address that the CPU will jump to when the corresponding interrupt occurs If the EBASE address is aligned to 4KB then all the interrupt vectors must be located within the 4KB from base address Example: When _ebase_address is set to 0x9D001000 and interrupts vectors are not located withing the 4KB boundary from the ebase address (OFFx 0x1000) then the bitwise OR operator may not provide correct interrupt vector address To provide maximum flexibility in placement of interrupt vectors: The _ebase_address is placed at start of Program flash memory (Example : 0x9D000000) like the default linker script Offsets of exceptions and vector sections are updated to place them from start of PFM With this the interrupt handlers can be located anywhere in the bootloader space of PFM Generated linker scripts as explained above is shown here as an example Bootloader length bootloader_length in the below snippet is auto generated based on the bootloader component added in MHC PROVIDE ( _vector_spacing =  0x0001 ) ;  PROVIDE ( _ebase_address =  0x9D000000 ) ;  /* Place the vector table and other exceptions after the device reset and * cache init code */  PROVIDE ( _ebase_vector_offsets =  0x1000 ) ; _RESET_ADDR =  0xBFC00000 ; _BEV_EXCPT_ADDR =  0xBFC00380 ; _DBG_EXCPT_ADDR =  0xBFC00480 ; _SIMPLE_TLB_REFILL_EXCPT_ADDR = _ebase_address + _ebase_vector_offsets +  0 ; _GEN_EXCPT_ADDR = _ebase_address + _ebase_vector_offsets +  0x180 ; kseg0_program_mem ( rx )  : ORIGIN =  0x9D000000  LENGTH =   bootloader_length  kseg1_boot_mem : ORIGIN =  0xBFC00000  LENGTH =  0x480 kseg1_boot_mem_4B0 : ORIGIN =  0xBFC004B0  LENGTH =  0x1000  -  0x4B0     config_BFC03F40 : ORIGIN =  0xBFC03F40  LENGTH =  0x4 config_BFC03F44 : ORIGIN =  0xBFC03F44  LENGTH =  0x4 config_BFC03F48 : ORIGIN =  0xBFC03F48  LENGTH =  0 SECTIONS {   config_BFC03F40 :  {  KEEP ( * (  config_BFC03F40 ) )  }   config_BFC03F40  config_BFC03F44 :  {  KEEP ( * (  config_BFC03F44 ) )  }   config_BFC03F44         }  /* Boot Sections */   reset _RESET_ADDR :  {  KEEP ( * (  reset ) )  KEEP ( * (  reset  startup ) )  }   kseg1_boot_mem     /* Interrupt vector table with vector offsets */   vectors _ebase_address + _ebase_vector_offsets +  0x200  :  {  /* Symbol __vector_offset_n points to vector_n if it exists * otherwise points to the default handler The * vector_offset_init o module then provides a data section * containing values used to initialize the vector-offset SFRs * in the crt0 startup code */    =  ALIGN ( 4 )  ; __vector_offset_0 =  ( DEFINED ( __vector_dispatch_0 )    (   - _ebase_address )  : __vector_offset_default ) ;  KEEP ( * (  vector_0 ) )          /* Default interrupt handler */    =  ALIGN ( 4 )  ; __vector_offset_default =    - _ebase_address ;  KEEP ( * (  vector_default ) )  }   kseg0_program_mem For Bootloaders placed in Boot Flash Memory (PIC32MX Devices) The bootloader start address by default will be start of Boot flash memory (0xBFC00000) This is the default startup location for all PIC32M devices The Initial 1280 Bytes (0x500) from Bootloader start address are used by Reset Handler and then followed by rest of bootloader code Length of the bootloader is calculated based on the bootloader being added to MHC In PIC32MX devices the _ebase_address holds the start address of vector table and it must be placed at 4KB boundary after the Reset Handler section Generated linker scripts as explained above is shown here as an example Bootloader length bootloader_length in the below snippet is auto generated based on the bootloader component added in MHC PROVIDE ( _vector_spacing =  0x0001 ) ;  PROVIDE ( _ebase_address =  0x9FC01000 ) ; _RESET_ADDR =  0xBFC00000 ; _BEV_EXCPT_ADDR =  0xBFC00380 ; _DBG_EXCPT_ADDR =  0xBFC00480 ; _DBG_CODE_ADDR =  0xBFC02000 ; _DBG_CODE_SIZE =  0xFF0 ; _GEN_EXCPT_ADDR = _ebase_address +  0x180 ; kseg0_program_mem ( rx )  : ORIGIN =  0x9FC00500  LENGTH =   bootloader_length  kseg1_boot_mem : ORIGIN =  0xBFC00000  LENGTH =  0x490     config3 : ORIGIN =  0xBFC02FF0  LENGTH =  0x4 config2 : ORIGIN =  0xBFC02FF4  LENGTH =  0x4 SECTIONS {   config_BFC02FF0 :  {  KEEP ( * (  config_BFC02FF0 ) )  }   config3  config_BFC02FF4 :  {  KEEP ( * (  config_BFC02FF4 ) )  }   config2 }  /* Boot Sections */   reset _RESET_ADDR :  {  KEEP ( * (  reset ) )  KEEP ( * (  reset  startup ) )  }   kseg1_boot_mem      vector_0 _ebase_address +  0x200  +  ( ( _vector_spacing   5 )  *  0 )  :  {  KEEP ( * (  vector_0 ) )  }   kseg0_program_mem ASSERT ( _vector_spacing ==  0  ||  SIZEOF (  vector_0 )  =  ( _vector_spacing   5 )   \"function at exception vector 0 too large\" )   vector_1 _ebase_address +  0x200  +  ( ( _vector_spacing   5 )  *  1 )  :  {  KEEP ( * (  vector_1 ) )  }   kseg0_program_mem ASSERT ( _vector_spacing ==  0  ||  SIZEOF (  vector_1 )  =  ( _vector_spacing   5 )   \"function at exception vector 1 too large\" )          For Bootloaders placed in Program Flash Memory (PIC32MX Devices) The bootloader start address by default will be start of Boot flash memory (0xBFC00000) This is the default startup location for all PIC32M devices As the entire bootloader cannot be placed in BFM Only the bootloader Reset Handler is placed in BFM Rest of the bootloader code will be placed from start of Program Flash memory The _ebase_address is placed at start of Program flash memory (Example : 0x9D000000) Generated linker scripts as explained above is shown here as an example Bootloader length bootloader_length in the below snippet is auto generated based on the bootloader component added in MHC PROVIDE ( _vector_spacing =  0x0001 ) ;  PROVIDE ( _ebase_address =  0x9D000000 ) ; _RESET_ADDR =  0xBFC00000 ; _BEV_EXCPT_ADDR =  0xBFC00380 ; _DBG_EXCPT_ADDR =  0xBFC00480 ; _DBG_CODE_ADDR =  0x9FC00490 ; _DBG_CODE_SIZE =  0x760 ; _GEN_EXCPT_ADDR = _ebase_address +  0x180 ; kseg0_program_mem ( rx )  : ORIGIN =  0x9D000000  LENGTH =   bootloader_length  kseg1_boot_mem : ORIGIN =  0xBFC00000  LENGTH =  0x490     config3 : ORIGIN =  0xBFC00BF0  LENGTH =  0x4 config2 : ORIGIN =  0xBFC00BF4  LENGTH =  0x4 SECTIONS {   config_BFC00BF0 :  {  KEEP ( * (  config_BFC00BF0 ) )  }   config3  config_BFC00BF4 :  {  KEEP ( * (  config_BFC00BF4 ) )  }   config2 }  /* Boot Sections */   reset _RESET_ADDR :  {  KEEP ( * (  reset ) )  KEEP ( * (  reset  startup ) )  }   kseg1_boot_mem      vector_0 _ebase_address +  0x200  +  ( ( _vector_spacing   5 )  *  0 )  :  {  KEEP ( * (  vector_0 ) )  }   kseg0_program_mem ASSERT ( _vector_spacing ==  0  ||  SIZEOF (  vector_0 )  =  ( _vector_spacing   5 )   \"function at exception vector 0 too large\" )   vector_1 _ebase_address +  0x200  +  ( ( _vector_spacing   5 )  *  1 )  :  {  KEEP ( * (  vector_1 ) )  }   kseg0_program_mem ASSERT ( _vector_spacing ==  0  ||  SIZEOF (  vector_1 )  =  ( _vector_spacing   5 )   \"function at exception vector 1 too large\" )          Using Both Boot Flash Panels on PIC32MZ device For PIC32MZ devices with two 80 KB Boot Flash panels bootloader may or may not fit entirely in one Boot Flash panel In order to fit some of the Bootloaders the linker script makes the two Boot Flash panels look like one contiguous Boot Flash memory Unimplemented areas are blocked using a fill command to the linker kseg0_program_mem ( rx )  : ORIGIN =  0x9FC01000  LENGTH =  0x2FF00  -  0x1000  /* Bootloader needs to be placed in both the Boot Flash Panels (lower and upper boot alias) Below region is used to fill 0xFF in reserved space between these two panles */ protected_reg : ORIGIN =  0x9FC14000  LENGTH =  0x20000 - 0x14000         SECTIONS {   fill1 :  {  FILL ( 0xFF ) ;    =  ORIGIN ( protected_reg )  +  LENGTH ( protected_reg )  -  1 ;  BYTE ( 0xFF )  }   protected_reg }  Note Device configuration bits should be updated by bootloader only The bootloader linker script is generated using generic templates for the device family Generated linker script should be modified if there any changes or modifications to the specific device being used ",
							" Bootloader linker configurations for CORTEX-M based MCUs Linker configurations for the UART I2C and CAN Bootloaders Bootloader library uses a custom linker script which is generated through MHC The values populated in the linker script are based on the Bootloader component MHC configurations Bootloader is configured to run from RAM in this linker script to achieve simultaneous Flash memory write and reception of the next block of data Note: The below sections provides overview of changes done to bootloader linker scripts when compared to default linker script The bootloader_start address and bootloader_length may vary based on the specific device used  # define ROM_START bootloader_start  /* Bootloader size is calculated with below criteria with optimization level -O2 * bootloader size = Minimum Flash Erase Size Or actual bootloader ELF size (Rounded of to nearest erase boundary) whichever is greater */  # define ROM_SIZE bootloader_length  /* Bootloader Trigger pattern needs to be stored in starting trigger_len Bytes * of Ram by the application if it wants to run bootloader at startup without any * external trigger * Example: * ram[0] = 0x5048434D; * ram[1] = 0x5048434D; * * ram[n] = 0x5048434D; */  # define RAM_START ( ram_start + trigger_len )  # define RAM_SIZE ( ram_length - trigger_len) MEMORY { rom ( rx )  : ORIGIN = ROM_START  LENGTH = ROM_SIZE ram ( rwx )  : ORIGIN = RAM_START  LENGTH = RAM_SIZE } SECTIONS {  /* * Configure to place the vector table in Flash but to be run from RAM */   vectors :  {    =  ALIGN ( 4 ) ; _sfixed =   ;  KEEP ( * (  vectors  vectors  * ) )  }   ram AT  rom  text :  {    =  ALIGN ( 4 ) ;              =  ALIGN ( 4 ) ; _efixed =   ;  /* End of text section */  }   rom             =  ALIGN ( 4 ) ; _etext =   ;  /* Locate text/rodata in special data section to be copied to RAM in startup sequence */   data :  {    =  ALIGN ( 4 ) ; __data_start__ =   ; _sdata =   ;  * (  dinit )  * (  text )  * (  text  * )  * (  rodata )  * (  rodata  * )    =  ALIGN ( 4 ) ; __data_end__ =   ; _edata =   ;  }   ram AT  rom      }  Custom startup file for UART I2C and CAN Bootloaders To reduce the size of the binary these bootloaders make use of custom startup file which is generated by MHC This startup file places only the Reset handler in vector table instead of populating all the device vectors there by reducing the size of final vector section This startup file also copies the entire bootloader code placed in data section above from flash to RAM as it is built to run from RAM  /* Declaration of Reset handler (may be custom) */  void  __attribute__ ( ( noinline ) )  Reset_Handler ( void ) ; __attribute__ ( ( used   section ( \" vectors\" ) ) )  void  ( *  const vectors [ ] ) ( void )  =  {   _ram_end_  Reset_Handler   } ;          /* Linker-defined symbols for data initialization */  extern uint32_t _sdata  _edata  _etext ;  extern uint32_t _sbss  _ebss ;  void  __attribute__ ( ( noinline   section ( \" romfunc Reset_Handler\" ) ) )  Reset_Handler ( void )  { uint32_t * pSrc   * pDst ; ; pSrc =  ( uint32_t * )   _etext ;  /* flash functions start after text */ pDst =  ( uint32_t * )   _sdata ;  /* boundaries of data area to init */  /* Copy code from flash to RAM using data section */  while  ( pDst    _edata )  * pDst ++  =  * pSrc ++ ;  /* Init bss */ pDst =   _sbss ;  while  ( pDst    _ebss )  * pDst ++  =  0 ;            }  MPLAB X Setting for UART I2C and CAN Bootloaders Below MPLAB X option is enabled by MHC for these bootloaders to remove the XC32 crt0 startup code By disabling this crt0 startup code we further reduce the size as it removes the default initialization mechanism code by XC32 arm_bootloader_config_xc32_ld_crt0 ",
							" Bootloader Sizing And Considerations Bootloader Sizes The example Bootloaders provided have XC32 optimization settings to -O2 However in terms of size this option does not produce the most optimal code Turning on the -Os will reduce the size of the Bootloader Note: By default the bootloader size will be rounded off to the nearest erase unit size of the device Size change considerations It must be ensured that the user applications memory region does not overlap with the memory region reserved for the Bootloader The Bootloader generated by MHC should be considered a starting point for your products Bootloader As such adding new features may cause the Bootloader to exceed the default size calculated If the size of the Bootloader changes the following steps should be performed to adjust both the Bootloader and the application in order to make sure that both fit and make best use of the device memory Increase the Bootloader Size in Bootloader MHC config menu to some approximate value and regenerate the code Determine the new ending address of the Bootloader This can be done by using either the map file generated by MPLAB X IDE with the respective Compiler or by using the ELFViewer plug-in for MPLAB X IDE Round the size from the map file to the nearest ERASE unit size value Enter the new value again in Bootloader Size in Bootloader MHC config menu Change the Application start Address from system settings in both Bootloader and application projects accordingly if it is falling inside bootloader region Recompile both the Bootloader and the application If only the Application start address needs to be modified for application then perform following steps: Change the Application start Address from system settings in both Bootloader and application projects accordingly Recompile both the Bootloader and the application ",
							" Configurations for the application to be bootloaded ",
							" Application project configurations for CORTEX-M based MCUs Application settings in MHC system configuration Launch MHC for the application project to be configured Select system component from the project graph and configure the below highlighted settings arm_application_config_mhc Disable Fuse Settings: Fuse settings needs to be disabled for the application which will be boot-loaded as the fuse settings are supposed to be programmed through programming tool from bootloader code Also the fuse settings are not programmable through firmware Enabling the fuse settings also increases the size of the binary when generated through the hex file When updating the bootloader itself make sure that the fuse settings for the bootloader application are also disabled Specify the Application Start Address: Specify the Start address from where the application will run under the Application Start Address (Hex) option in System block in MHC This value should be equal to or greater than the bootloader size and must be aligned to the erase unit size on that device As this value will be used by bootloader to Jump to application at device reset it should match the value provided to bootloader code The Application Start Address (Hex) will be used to generate XC32 compiler settings to place the code at intended address After the project is regenerated the ROM_ORIGIN and ROM_LENGTH are the XC32 linker variables which will be overridden with value provided for Application Start Address (Hex) and can be verified under Options for xc32-ld in Project Properties in MPLABX IDE as shown below arm_application_config_xc32_ld_rom MPLAB X Settings For Bootloading the application using binary file Below are the Bootloaders which use application binary ( bin) file as input UART I2C CAN Serial Memory File System Specifying post build option to automatically generate the binary file from hex file once the build is complete $ { MP_CC_DIR } / xc32 - objcopy - I ihex - O binary $ { DISTDIR } / $ { PROJECTNAME }  $ { IMAGE_TYPE }  hex $ { DISTDIR } / $ { PROJECTNAME }  $ { IMAGE_TYPE }  bin arm_application_config_post_build_script For Bootloading the application using Normalized Hex file Below are the Bootloaders which use Normalized application Hex ( hex) file as input USB Device HID UDP Check the Normalize hex file option as shown below as the Unified bootloader host application takes hex file as an input Normalizing the hex file will make sure the data in the hex file is arranged sequentially arm_application_config_normalize_hex Additional settings (Optional) RAM_ORIGIN and RAM_LENGTH values should be provided for reserving configured bytes from start of RAM to trigger bootloader from firmware Under Project Properties expand options for xc32-ld and define the values for RAM_ORIGIN and RAM_LENGTH under Additional options This is optional and can be ignored if not required arm_application_config_xc32_ld_ram ",
							" Application project configurations for MIPS based MCUs Application Settings in MHC System Configuration Disable default linker file generation in system settings from MHC As the application to be bootloaded will be using a custom linker file mips_application_config_mhc MPLAB X Settings For Bootloading the application using binary file Below are the Bootloaders which use application binary ( bin) file as input UART I2C CAN Serial Memory File System Specifying post build option to automatically generate the binary file from hex file once the build is complete $ { MP_CC_DIR } / xc32 - objcopy - I ihex - O binary $ { DISTDIR } / $ { PROJECTNAME }  $ { IMAGE_TYPE }  hex $ { DISTDIR } / $ { PROJECTNAME }  $ { IMAGE_TYPE }  bin mips_application_config_post_build_script For Bootloading the application using Normalized Hex file Below are the Bootloaders which use Normalized application Hex ( hex) file as input USB Device HID UDP Check the Normalize hex file option as shown below as the Unified bootloader host application takes hex file as an input Normalizing the hex file will make sure the data in the hex file is arranged sequentially mips_application_config_normalize_hex ",
							" Application linker configurations for MIPS based MCUs Bootloader placement for various PIC32M product families The bootloader is placed in Boot Flash Memory (BFM) or Program Flash Memory (PFM) based on the size of the bootloader and available Boot flash memory on the device If the bootloader fits into the available BFM it is placed in BFM The user application can use the complete area of the program Flash memory If the bootloader does not fit into the available BFM it is placed in PFM The user application can use the remaining area of the program Flash memory The following table shows the available Boot Flash memory and the placement of different bootloaders by product family bootloader_placement Setting up the Application linker script The linker script file of the application project has to be modified to place the vector table and reset handlers in program flash memory For Quick start Refer to pre developed application linker scripts app_XX ld placed in projects device specific configuration folder of bootloader_apps_xxx/ repository For example: mips_application_linker_file Reset Address for the application to be loaded through bootloader should match the Application start address mentioned in bootloader project The vector address of a given interrupt is calculated using Exception Base (EBASE) CPU register and the _ebase_address should be aligned to 4KB boundary Note: The below sections provides overview of changes required in the applications linker scripts The address location and size may vary based on the specific device used For Bootloaders placed in Boot Flash Memory (PIC32MZ and PIC32MK Devices) The application start address by default will be start of program flash memory Refer to specific device datasheet for program flash memory start address and length The Initial 4KB from Application start address are used by Reset Handler and and cache_init section XC32 Compiler calculates offset from the EBASE address and initializes the value of interrupt vector offset (OFFx) register The offset register is combined with EBASE register using a bitwise OR operator to obtain the interrupt vector address that the CPU will jump to when the corresponding interrupt occurs If the EBASE address is aligned to 4KB then all the interrupt vectors must be located within the 4KB from base address Example: When _ebase_address is set to 0x9D001000 and interrupts vectors are not located withing the 4KB boundary from the ebase address (OFFx 0x1000) then the bitwise OR operator may not provide correct interrupt vector address To provide maximum flexibility in placement of interrupt vectors: Always place the _ebase_address at start of Program flash memory (Example : 0x9D000000) like the default linker script Change the offsets of exceptions and vector section to place them after the device startup code With this the interrupt handlers can be located anywhere in the Program Flash memory Updated linker scripts as explained above is shown here as an example Note: Cache related sections are not applicable for PIC32MK Devices PROVIDE ( _vector_spacing =  0x0001 ) ;  PROVIDE ( _ebase_address =  0x9D000000 ) ;  /* Place the vector table and other exceptions after the device reset and * cache init code */  PROVIDE ( _ebase_vector_offsets =  0x1000 ) ; _RESET_ADDR =  0xBD000000 ; _SIMPLE_TLB_REFILL_EXCPT_ADDR = _ebase_address + _ebase_vector_offsets +  0 ; _CACHE_ERR_EXCPT_ADDR = _ebase_address + _ebase_vector_offsets +  0x100 ; _GEN_EXCPT_ADDR = _ebase_address + _ebase_vector_offsets +  0x180 ; kseg0_program_mem ( rx )  : ORIGIN =  0x9D001000  LENGTH =  0x200000  -  0x1000 kseg1_boot_mem : ORIGIN =  0xBD000000  LENGTH =  0x480 kseg1_boot_mem_4B0 : ORIGIN =  0xBD0004B0  LENGTH =  0x1000  -  0x4B0  /* Boot Sections */   reset _RESET_ADDR :  {  KEEP ( * (  reset ) )  KEEP ( * (  reset  startup ) )  }   kseg1_boot_mem  cache_init :  {  * (  cache_init )  * (  cache_init  * )  }   kseg1_boot_mem_4B0     /* Interrupt vector table with vector offsets */   vectors _ebase_address + _ebase_vector_offsets +  0x200  :  {  /* Symbol __vector_offset_n points to vector_n if it exists * otherwise points to the default handler The * vector_offset_init o module then provides a data section * containing values used to initialize the vector-offset SFRs * in the crt0 startup code */    =  ALIGN ( 4 )  ; __vector_offset_0 =  ( DEFINED ( __vector_dispatch_0 )    (   - _ebase_address )  : __vector_offset_default ) ;  KEEP ( * (  vector_0 ) )          /* Default interrupt handler */    =  ALIGN ( 4 )  ; __vector_offset_default =    - _ebase_address ;  KEEP ( * (  vector_default ) )  }   kseg0_program_mem For Bootloaders placed in Program Flash Memory (PIC32MK Devices) The bootloader code resides from start of Program flash memory hence the application start address has to be after the end of bootloader Refer to specific device datasheet for program flash memory start address and length The Initial 4KB from Application start address are used by Reset Handler section XC32 Compiler calculates offset from the EBASE address and initializes the value of interrupt vector offset (OFFx) register The offset register is combined with EBASE register using a bitwise OR operator to obtain the interrupt vector address that the CPU will jump to when the corresponding interrupt occurs If the EBASE address is aligned to 4KB then all the interrupt vectors must be located within the 4KB from base address Example: When _ebase_address is set to 0x9D001000 and interrupts vectors are not located withing the 4KB boundary from the ebase address (OFFx 0x1000) then the bitwise OR operator may not provide correct interrupt vector address To provide maximum flexibility in placement of interrupt vectors: Always place the _ebase_address at start of Program flash memory (Example : 0x9D000000) like the default linker script Note: As _ebase_address is only used to calculate the vector offset it can be placed at start of program flash memory even though the bootloader code is residing there Change the offsets of exceptions and vector section to place them after the device startup code of application With this the interrupt handlers can be located anywhere in the Program Flash memory after bootloader space Updated linked scripts as explained above is shown here as an example  Bootloader length bootloader_length in the below snippet needs to be replaced with size of the respective bootloader PROVIDE ( _vector_spacing =  0x0001 ) ;  PROVIDE ( _ebase_address =  0x9D000000 ) ;  /* Place the vector table and other exceptions after the device reset and * cache init code */  PROVIDE ( _ebase_vector_offsets =   bootloader_length   +  0x1000 ) ; _RESET_ADDR =  0xBD000000  +   bootloader_length  ; _SIMPLE_TLB_REFILL_EXCPT_ADDR = _ebase_address + _ebase_vector_offsets +  0 ; _GEN_EXCPT_ADDR = _ebase_address + _ebase_vector_offsets +  0x180 ; kseg0_program_mem ( rx )  : ORIGIN =  0x9D000000  +   bootloader_length   +  0x1000  LENGTH =  0x200000  -   bootloader_length   -  0x1000 kseg1_boot_mem : ORIGIN =  0xBD000000  +   bootloader_length   LENGTH =  0x1000  /* Boot Sections */   reset _RESET_ADDR :  {  KEEP ( * (  reset ) )  KEEP ( * (  reset  startup ) )  }   kseg1_boot_mem     /* Interrupt vector table with vector offsets */   vectors _ebase_address + _ebase_vector_offsets +  0x200  :  {  /* Symbol __vector_offset_n points to vector_n if it exists * otherwise points to the default handler The * vector_offset_init o module then provides a data section * containing values used to initialize the vector-offset SFRs * in the crt0 startup code */    =  ALIGN ( 4 )  ; __vector_offset_0 =  ( DEFINED ( __vector_dispatch_0 )    (   - _ebase_address )  : __vector_offset_default ) ;  KEEP ( * (  vector_0 ) )          /* Default interrupt handler */    =  ALIGN ( 4 )  ; __vector_offset_default =    - _ebase_address ;  KEEP ( * (  vector_default ) )  }   kseg0_program_mem For Bootloaders placed in Boot Flash Memory (PIC32MX Devices) The application start address by default will be start of program flash memory Refer to specific device datasheet for program flash memory start address and length The Initial 4KB are used by Reset Handler section In PIC32MX devices the _ebase_address holds the start address of vector table and it must be placed at 4KB boundary after the Reset Handler section Updated linked scripts as explained above is shown here as an example PROVIDE ( _vector_spacing =  0x0001 ) ;  PROVIDE ( _ebase_address =  0x9D001000 ) ; _RESET_ADDR =  0xBD000000 kseg0_program_mem ( rx )  : ORIGIN =  0x9D001000  LENGTH =  0x80000  -  0x1000 kseg1_boot_mem : ORIGIN =  0xBD000000  LENGTH =  0x1000  /* Boot Sections */   reset _RESET_ADDR :  {  KEEP ( * (  reset ) )  KEEP ( * (  reset  startup ) )  }   kseg1_boot_mem      vector_0 _ebase_address +  0x200  +  ( ( _vector_spacing   5 )  *  0 )  :  {  KEEP ( * (  vector_0 ) )  }   kseg0_program_mem ASSERT ( _vector_spacing ==  0  ||  SIZEOF (  vector_0 )  =  ( _vector_spacing   5 )   \"function at exception vector 0 too large\" )   vector_1 _ebase_address +  0x200  +  ( ( _vector_spacing   5 )  *  1 )  :  {  KEEP ( * (  vector_1 ) )  }   kseg0_program_mem ASSERT ( _vector_spacing ==  0  ||  SIZEOF (  vector_1 )  =  ( _vector_spacing   5 )   \"function at exception vector 1 too large\" )          For Bootloaders placed in Program Flash Memory (PIC32MX Devices) The bootloader code resides from start of Program flash memory hence the application start address has to be after the end of bootloader The Initial 4KB from Application start address are used by Reset Handler section Place the _ebase_address after the device startup code of application Updated linked scripts as explained above is shown here as an example Bootloader length bootloader_length in the below snippet needs to be replaced with size of the respective bootloader PROVIDE ( _vector_spacing =  0x0001 ) ;  PROVIDE ( _ebase_address =  0x9D000000  +   bootloader_length   +  0x1000 ) ; _RESET_ADDR =  0xBD000000  +   bootloader_length  ; kseg0_program_mem ( rx )  : ORIGIN =  0x9D000000  +   bootloader_length   +  0x1000  LENGTH =  0x80000  -   bootloader_length   -  0x1000 kseg1_boot_mem : ORIGIN =  0xBD000000  +   bootloader_length   LENGTH =  0x1000  /* Boot Sections */   reset _RESET_ADDR :  {  KEEP ( * (  reset ) )  KEEP ( * (  reset  startup ) )  }   kseg1_boot_mem      vector_0 _ebase_address +  0x200  +  ( ( _vector_spacing   5 )  *  0 )  :  {  KEEP ( * (  vector_0 ) )  }   kseg0_program_mem ASSERT ( _vector_spacing ==  0  ||  SIZEOF (  vector_0 )  =  ( _vector_spacing   5 )   \"function at exception vector 0 too large\" )   vector_1 _ebase_address +  0x200  +  ( ( _vector_spacing   5 )  *  1 )  :  {  KEEP ( * (  vector_1 ) )  }   kseg0_program_mem ASSERT ( _vector_spacing ==  0  ||  SIZEOF (  vector_1 )  =  ( _vector_spacing   5 )   \"function at exception vector 1 too large\" )          Note The bootloader and the application must have the same device configuration bit settings The Device configuration bit settings from the bootloader project will be updated by the programmer/debugger Hence the application linker script should not have any device configuration bit settings The application project will use the device configuration bit settings done by bootloader Device configurations and debug exception need to discarded from final hex file for the application project / DISCARD /  :  {  * (  _debug_exception )  }  / DISCARD /  :  {  * (  config_ * )  } Additional settings (Optional) Data Memory Origin and Data Memory Length values should be updated in linkerscript for reserving configured bytes from start of RAM to trigger bootloader from firmware /* Reserve trigger_len Bytes to Store Bootloader Trigger Pattern */ kseg0_data_mem ( w  x )  : ORIGIN =   ram_start   +   trigger_len   LENGTH =   ram_length   -   trigger_len  ",
							" UART Bootloader Library Interface Name Description bootloader_Tasks Starts bootloader execution bootloader_Trigger Checks if Bootloader has to be executed at startup run_Application Runs the programmed application at startup bootloader_ProgramFlashBankSelect Selects Appropriate Program Flash Bank after reset ",
							" bootloader_Tasks Function void  bootloader_Tasks ( void ) Summary Starts bootloader execution Description This function can be used to start bootloader execution The function waits for application firmware from the Host devices (Host-PC/Embedded Host/Serial Memory) based on the bootloader running Once the complete application is received programmed and verified successfully it resets the device to jump into programmed application Precondition bootloader_Trigger() must be called to check for bootloader triggers at startup Parameters None Returns None Example bootloader_Tasks ( ) ; Remarks For UART I2C and CAN bootloaders this function runs in a infinite loop and it never returns ",
							" bootloader_Trigger Function bool bootloader_Trigger ( void ) ; Summary Checks if Bootloader has to be executed at startup Description This function can be used to check for a External HW trigger or Internal firmware trigger to execute bootloader at startup This function has to be implemented by the bootloader application to override the WEAK implementation in bootloader c The checks in trigger function should happen before any system resources are initialized apart for PORT As the same system resource can be Re-initialized by the application if bootloader jumps to it and may cause issues External Trigger: Can be achieved by triggering a GPIO_PIN at startup Firmware Trigger: Application firmware which wants to execute bootloader at startup needs to fill first n bytes of ram location with a request pattern The Number of bytes to be reserved for storing the pattern has to be configured in bootloader component configuration in MHC uint32_t * sram =  ( uint32_t * ) BTL_TRIGGER_RAM_START ; sram [ 0 ]  =  0x5048434D ; sram [ 1 ]  =  0x5048434D ; sram [ 2 ]  =  0x5048434D ; sram [ 3 ]  =  0x5048434D ; Precondition PORT/PIO Initialize must have been called Parameters None Returns True : If any of trigger is detected False : If no trigger is detected Example # define BTL_TRIGGER_PATTERN 0x5048434D  static uint32_t * ramStart =  ( uint32_t * ) BTL_TRIGGER_RAM_START ; bool bootloader_Trigger ( void )  {  // Check for Bootloader Trigger Pattern in first 16 Bytes of RAM to enter Bootloader  if  ( BTL_TRIGGER_PATTERN == ramStart [ 0 ]   BTL_TRIGGER_PATTERN == ramStart [ 1 ]   BTL_TRIGGER_PATTERN == ramStart [ 2 ]   BTL_TRIGGER_PATTERN == ramStart [ 3 ] )  { ramStart [ 0 ]  =  0 ;  return true ;  }  // Check for Switch press to enter Bootloader  if  ( SWITCH_Get ( )  ==  0 )  {  return true ;  }  return false ;  }  void  SYS_Initialize ( )  {  NVMCTRL_Initialize ( ) ;  PORT_Initialize ( ) ;  if  ( bootloader_Trigger ( )  == false )  {  run_Application ( ) ;  }  CLOCK_Initialize ( ) ;  }  ",
							" run_Application Function void  run_Application ( void ) ; Summary Runs the programmed application at startup Description This function can be used to run programmed application though bootloader at startup If the first 4Bytes of Application Memory is not 0xFFFFFFFF then it jumps to the application start address to run the application programmed through bootloader and never returns If the first 4Bytes of Application Memory is 0xFFFFFFFF then it returns from function and executes bootloader for accepting a new application firmware Precondition bootloader_Trigger() must be called to check for bootloader triggers at startup Parameters None Returns None Example void  SYS_Initialize ( )  {  NVMCTRL_Initialize ( ) ;  PORT_Initialize ( ) ;  if  ( bootloader_Trigger ( )  == false )  {  run_Application ( ) ;  }  CLOCK_Initialize ( ) ;  }  ",
							" bootloader_ProgramFlashBankSelect Function void  bootloader_ProgramFlashBankSelect (  void  ) ; Summary Selects Appropriate Program Flash Bank after reset Description This function can be used to select the appropriate Program flash bank based on the serial number stored at fixed location in each of the bank after reset Bootloader should know the address at compile time where the serial number is stored in each bank It reads the serial number from both banks Compares the values and maps the bank with highest serial number to lower region Note: This Function will be generated only for MIPS based MCUs with dual flash bank support and when the dual bank support option is selected in MHC bootloader component settings Refer to Bootloader Configurations section for more details Precondition PORT/PIO Initialize must have been called This Function should be called before calling bootloader_Trigger() function Parameters None Returns None Example bootloader_ProgramFlashBankSelect (  void  ) ;  if  ( bootloader_Trigger ( )  == false )  {  run_Application ( ) ;  }  ",
							" UART Bootloader Host Script Help Downloading the host script To clone or download these host tools from Github go to the main page of this repository and then click Clone button to clone this repo or download as zip file This content can also be download using MCC content manager Path of the tool within the repository is tools/btl_host py Setting up the Host PC The Script is compatible with Python 3 x and higher It requires pyserial package to communicate with device over UART Use below command to install the pyserial package pip3 install pyserial Description This host script should be used to communicate with the Bootloader running on the device via UART interface It is a command line interface and implements the bootloader protocol required to communicate from host PC If size of the input binary file is not aligned to device erase boundary it appends 0xFF to the binary to make it aligned and then sends the binary to the device It should be used with -s (--swap) option when using bootloader in fail safe update mode to trigger a swap bank and reset It should be used with -b (--boot) option with address as 0x0 when updating the bootloader itself on CORTEX-M based MCUs Usage Examples Below is the syntax to show help menu for the script python harmony3_path /bootloader/tools/btl_host py --help btl_host_help_menu png Bootloader basic mode syntax and example Below syntax and example can be used to program a binary and send a Reset command python harmony3_path /bootloader/tools/btl_host py -v -i COM PORT -d Device Name -a address -f Application_binary_path python  harmony3_path  / bootloader / tools / btl_host  py - v - i COM18 - d same5x - a 0x2000  - f  harmony3_path  / bootloader_apps_uart / apps / uart_bootloader / test_app / firmware / sam_e54_xpro  X / dist / sam_e54_xpro / production / sam_e54_xpro  X  production  bin btl_host_output Bootloader Fail Safe Update mode syntax and example Below syntax and example can be used to program a binary in Inactive Bank and send a Swap Bank and Reset command python harmony3_path /bootloader/tools/btl_host py -v -s -i COM PORT -d Device Name -a Inactive Bank address -f Path to application binary Example to send Bootloader binary in inactive bank python  harmony3_path  / bootloader / tools / btl_host  py - v - s - i COM18 - d same5x - a 0x80000  - f  harmony3_path  / bootloader_apps_uart / apps / uart_fail_safe_bootloader / bootloader / firmware / sam_e54_xpro  X / dist / sam_e54_xpro / production / sam_e54_xpro  X  production  bin Example to send Application binary in inactive bank python  harmony3_path  / bootloader / tools / btl_host  py - v - s - i COM18 - d same5x - a 0x82000  - f  harmony3_path  / bootloader_apps_uart / apps / uart_fail_safe_bootloader / test_app / firmware / sam_e54_xpro  X / dist / sam_e54_xpro / production / sam_e54_xpro  X  production  bin btl_host_swap_bank_output Example to send te merged binary in inactive bank using btl_host py python  harmony3_path  / bootloader / tools / btl_host  py - v - s - i COM18 - d same5x - a 0x80000  - f  Path_to_merged_binary  / btl_app_merged  bin ",
							" Bootloader and Application binary merge script Help Downloading the host script To clone or download these host tools from Github go to the main page of this repository and then click Clone button to clone this repo or download as zip file This content can also be download using MCC content manager Path of the tool within the repository is tools/btl_app_merge_bin py Setting up the Host PC The Script is compatible with Python 3 x and higher Description This script should be used to merge the bootloader binary and application binary It creates a merged binary output where bootloader is placed from start and the application will be placed at the offset passed as parameter If the application offset is not equal to end of bootloader offset it fills the gap with 0xFF until the application offset The merged binary can be used by btl_host py as input for Updating bootloader and application together The merged binary will be created in the directory from where the script was called btl_app_merge_bin Usage Examples Below is the syntax to show help menu for the script python harmony3_path /bootloader/tools/btl_app_merge_bin py --help btl_app_merge_bin_help_menu Below is the syntax and an example on how to merge a bootloader binary and application binary python harmony3_path /bootloader/tools/btl_app_merge_bin py -o Offset -b Bootloader_binary_path -a Application_binary_path python  harmony3_path  / bootloader / tools / btl_app_merge_bin  py - o 0x2000  - b  harmony3_path  / bootloader_apps_uart / apps / uart_fail_safe_bootloader / bootloader / firmware / sam_e54_xpro  X / dist / sam_e54_xpro / production / sam_e54_xpro  X  production  bin - a  harmony3_path  / bootloader_apps_uart / apps / uart_fail_safe_bootloader / test_app / firmware / sam_e54_xpro  X / dist / sam_e54_xpro / production / sam_e54_xpro  X  production  bin btl_app_merge_bin_output python  harmony3_path  / bootloader / tools / btl_host  py - v - s - i COM18 - d same5x - a 0x80000  - f  Path_to_merged_binary  / btl_app_merged  bin btl_host_swap_bank_output ",
							" Debugging Bootloader and Application to be bootloaded Debugging Bootloader For CORTEX-M based MCUs see Debugging Bootloaders For CORTEX-M based MCUs see topic below MIPS based MCUs Can be debugged as any other MPLAB project No additional setup is required ",
							" Debugging UART I2C and CAN Bootloaders for CORTEX-M based MCUs The UART I2C and CAN bootloaders for CORTEX-M based MCU's are designed to run from SRAM to support Simultaneous Flash memory write and reception of the next block of data Self update bootloader_ram_layout For debugging these bootloaders make use of software breakpoints instead of Hardware breakpoints Steps to enable software breakpoints and start debugging Enable software breakpoint from the project configuration dashboard by clicking on the button as shown below arm_bootloader_debug_enable_soft_breakpoint Software breakpoints inside main() when running from SRAM do not work when set before starting the debugger For them to work first set a Breakpoint in startup_xc32 c file as it is running from flash arm_bootloader_debug_set_startup_breakpoint Start the debugger from MPLAB IDE and the software break point in startup file will be hit arm_bootloader_debug_startup_breakpoint_hit Once the breakpoint is hit in startup file then set breakpoints anywhere you want like in main() function as shown below arm_bootloader_debug_set_main_breakpoint Resume the debugger and you should be able to now debug as usual arm_bootloader_debug_main_breakpoint_hit ",
							" Debugging Bootloader and Application to be bootloaded Open the bootloader project to be debugged in the MPLAB IDE Make sure that the application to be bootloaded and debugged is added as a loadable project to bootloader project Adding the application as loadable allows MPLAB X to create a unified hex file and program both bootloader and application in thier respective memory locations Bootloader in bootloader space Application in application space debugging_bootloader_app_loadable Open the application project in the IDE and disable post build script exection if any as shown below Having this binary conversion post build script enabled will result in build error during debugging as there will be no hex file generated debugging_bootloader_app_disable_post_build_script Set breakpoint as required in application project Below is a an example snapshot debugging_bootloader_app_set_breakpoint Start debugger for the bootloader project using the IDE This should program both bootloader and application debugging_bootloader_app_start Once the debugger is started the bootloader first runs and then jumps to application code You should see the application breakpoint hit if application code is running debugging_bootloader_app_breakpoint_hit Additional Information (For MIPS based MCUs) When combining the Bootloader and Application Hex files in MPLAB X IDE an error may be generated if the device Configuration words are different This will be shown as a data conflict error and the address given will match an address in the device Configuration words This can be resolved by discarding the Device Configuration settings from application linker file as shown below / DISCARD /  :  {  * (  config_ * )  } ",
							" I2C Bootloader The I2C bootloader Library can be used to upgrade firmware on a target device without the need for an external programmer or debugger Features Supported Only on CortexM0+ and CortexM4 based Devices Uses Harmony 3 I2C PLIB to communicate resulting in smaller bootloader size Supports Fail Safe update Takes Binary File as input Receives Binary from an I2C Embedded Host Device Running From SRAM (For SAM Devices) Has capability to self update as it is running from SRAM bootloader_ram_layout At reset the bootloader Reset handler copies the entire bootloader firmware into SRAM from Start location and start executing from SRAM Once the application is called from bootloader applications startup code takes control over SRAM and starts executing I2C Bootloader Block Diagram i2c_bootloader_block_diagram I2C Event Processor Task: This task is responsible for receiving data from Embedded Host through the I2C communication interface The task polls and processes the I2C events Based on the event received it gives control to I2C Master Write Request or I2C Master Read Request functions This task is responsible for responding to the bootloader commands received I2C Master Write Request: This function is responsible to handle any write requests coming from I2C master It processes the commands received and notifies the status to I2C Event Process Task If the command received is a Erase/Prgram/Verify command it gives control to the Flash task I2C Master Read Request: This function is responsible to handle any read requests coming from I2C master It sends the current status to I2C master if the command received is Read Status Flash Task: This task is responsible to Erase/Prgram/Verify the internal flash memory with data packet received The task uses the NVM peripheral library to perform the Unlock/Erase/Write Operations ",
							" How the I2C Bootloader library works The CAN Bootloader firmware communicates with the embedded host device by using a predefined communication protocol The I2C Bootloader works in two different modes Basic Mode This mode is supported for all the devices Resides from The starting location of the flash memory region for CORTEX-M based MCUs The Bootloader performs flash erase/program/verify operations with the binary sent from host while in the firmware upgrade mode The binary sent is only of the application to be programmed Bootloader always performs flash operation from the address for (bootloader or application) binary sent from host The application can use the entire flash memory region starting from the end of bootloader space Jumps to the application once verification is completed Fail Safe Update Mode This mode is supported for the devices which have a Dual Bank flash memory Resides from the starting location of the flash memory region of both the banks on CORTEX-M based MCUs The Bootloader performs flash erase/program/verify operations with the binary sent from host while in the firmware upgrade mode Bootloader can perform flash operation in either of the banks based on the address sent by the host application The application can use only the flash memory region of one bank Performs a bank swap and reset to run the application programmed in opposite bank once verification is completed or a normal reset to run the application in current bank based on command sent from host ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" I2C Bootloader Protocol Each command argument is of 4 bytes and must be sent in big-endian (MSB first) format Unlock Command (0xA0) Unlock command is used to specify the application start address and size of the application Unlock command must be issued before issuing any other command Payload: Arg 0 - Application start address The start address is device dependent and must be aligned to an Erase Unit boundary which is also device dependent Arg 1 - Application size It must be rounded off to the nearest erase unit size i2c_bootloader_unlock_command_range The memory address range specified in Unlock command will be used to validate the addresses sent for other commands The memory address specified by all other commands must lie within the address range specified for the Unlock command Bootloader will calculate CRC over the entire range of memory specified by the Unlock command i2c_bootloader_unlock_command Erase Command (0xA1) Erase command erases a flash page as specified by the Erase Page Address argument Payload: Arg 0 - Starting memory address of the flash page being erased The flash page being erased must lie within the address range specified by the Unlock command else the bootloader will NAK the command and the INVALID ADDRESS error bit will be set in the status byte If the command is accepted successfully the bootloader will set the BUSY bit in the status byte The host application must poll the status byte and ensure that the command is completed successfully (status byte indicates bootloader is not busy and no error bits are set) before issuing a new command i2c_bootloader_erase_command Note: Depending on the value specified for Bootloader Commands Stretch I2C Clock the bootloader may either stretch the I2C clock or respond with NAK while it is busy Program Command (0xA2) Program command is used to send the image data Payload: Arg 0: Number of bytes to program It must be a multiple of the flash page size Depending on the value specified one or more flash pages within the erase unit can be programmed For example if the erase row size is 256 bytes and program page size is 64 bytes the number of bytes to program can either be 64 128 192 or 256 Arg 1: Program Memory Address It must be aligned to the start address of the flash page being programmed The flash page being programmed must lie within the address range specified by the Unlock command; else the bootloader will NAK the command and the INVALID ADDRESS error bit will be set in the status byte If the command is accepted successfully the bootloader will set the busy bit in the status byte The host application must poll the status byte and ensure that the command is completed successfully (status byte indicates bootloader is not busy and no error bits are set) before issuing a new command The bootloader host application must ensure that the flash page being programmed is erased before issuing the Program Command i2c_bootloader_program_command Note: Depending on the value specified for Bootloader Commands Stretch I2C Clock the bootloader may either stretch the I2C clock or respond with NAK while it is busy Verify Command (0xA3) Verify command is used to verify the programmed application image Payload: Arg 0: Application Image CRC CRC is a standard IEEE CRC32 with a polynomial of 0xEDB88320 The bootloader host application must calculate the CRC of the application image over the entire memory range specified in the Unlock command and provide it to the bootloader The CRC is a standard IEEE CRC32 with a polynomial of 0xEDB88320 The bootloader upon receiving the Verify command calculates the CRC over the range of addresses specified by the Unlock command by reading the flash memory contents and compares it with the received CRC value If the command is accepted successfully the bootloader will set the busy bit in the status byte The host application must poll the status byte and ensure that the CRC verification is successful (status byte indicates bootloader is not busy and no error bits are set) before issuing the Reset Command If the calculated CRC and received CRC values do not match the CRC_ERROR bit is set in the Status byte i2c_bootloader_verify_command Note: The bootloader will stretch the I2C clock while it is busy verifying the application image Reset Command (0xA4) Reset command is used to exit the bootloader and run the application The system takes a reset after receiving the Reset Command i2c_bootloader_reset_command Read Status Command (0xA5) Returns the bootloader status The bootloader status can be read any time i2c_bootloader_status_byte_command Flash Bank Swap and Reset Command (0xA6) Resets the device and swaps the flash bank i2c_bootloader_bank_swap_reset_command This command is enabled only when Fail safe update feature is selected for bootloader and the device has support for Dual Bank update Bank Swap and Reset command is used to Swap the inactive bank to active bank and trigger a reset to exit the bootloader and run the new application programmed in the inactive bank ",
							" I2C Bootloader system level execution flow Bootloader system level execution flow The Bootloader code starts executing on a device Reset If there are no conditions to enter the firmware upgrade mode the Bootloader starts executing the user application Refer to Bootloader Trigger Methods for different conditions to enter firmware upgrade mode The Bootloader performs Flash erase/program operations while in the firmware upgrade mode basic_bootloader_execution_flow ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" I2C Bootloader Firmware Update mode execution flow There are two state machines One state machine processes the I2C events parses the recevied I2C packets and triggers flash operations The second state machine performs the flash operations (read/write/verify) Bootloader I2C Events Processor Task Flow Bootloader I2C Events Processor Task polls and processes the I2C events This task is responsible for parsing and responding to the bootloader commands Once complete packet is received it sets the BUSY flag in the status byte and also sets appropriate flags for the Flash Programming Task to execute the command (Erase/Program/Verify) i2c_events_process_state_machine Flash Programming Task Flow This task is responsible for executing the Erase/Program and Verify commands This task is non-blocking It submits a Erase/Program request and then checks the status of flash operation whenever it gets a chance to run Once the flash operation is complete it clears the BUSY flag and sets appropriate error flags (if any) in the status byte i2c_flash_state_machine  ",
							" I2C Bootloader Configurations Bootloader Specific User Configurations i2c_bootloader_mhc_config_sam Bootloader Peripheral Used: Specifies the communication peripheral used by bootloader to receive the application The name of the peripheral will vary from device to device Bootloader NVM Memory Used: Specifies the memory peripheral used by bootloader to perform flash operations The name of the peripheral will vary from device to device Bootloader Size (Bytes): Specifies the maximum size of flash required by the bootloader This size is calculated based on Bootloader type and Memory used This size will vary from device to device and should always be aligned to device erase unit size Enable Bootloader Trigger From Firmware: This Option can be used to Force Trigger bootloader from application firmware after a soft reset It does so by reserving the specified number of bytes in SRAM from the start of the RAM The reserved memory is updated by the application with a pre-defined pattern The bootloader firmware in the bootloader_Trigger() routine can check the reserved memory for the pre-defined pattern and enter bootloader mode if the pattern matches Number Of Bytes To Reserve From Start Of RAM: This option adds the provided offset to RAM Start address in bootloader linker script Application firmware can store some pattern in the reserved bytes region from RAM start for bootloader to check at reset in bootloader_Trigger() function Bootloader Commands Stretch I2C Clock: This Option is used to decide if bootloader stretches clock when it is busy or sends NAK Enabling this option stretches the I2C clock when the bootloader is busy with the internal flash erase or write operation The clock is stretched during the acknowledgement phase This frees the I2C host from repeatedly polling the status of the sent command If this option is disabled the bootloader responds with a NAK while it is busy with the internal flash erase or write operation This allows the I2C host to communicate with other slaves on the same bus while the bootloader is busy Use Dual Bank For Safe Flash Update: Used to configure bootloader to use Dual banks of device to upload the application This option is visible only for devices supporting Dual flash banks Bootloader System Configurations i2c_bootloader_mhc_config_system Application Start Address (Hex): Start address of the application which will programmed by bootloader This value is filled by bootloader when its loaded which is equal to the bootloader size It can be modified as per user need This value will be used by bootloader to Jump to application at device reset Note For optimizing the code Bootloader component disables generation of default interrupt and exception files as shown below Enabling these interrupts explicitly may still not work as bootloader uses custom startup file which has its own Interrupt table populating only the reset handler i2c_bootloader_mhc_config_interrupt_disable ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" I2C Bootloader Library Interface Name Description bootloader_Tasks Starts bootloader execution bootloader_Trigger Checks if Bootloader has to be executed at startup run_Application Runs the programmed application at startup ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" I2C/CAN Bootloader Tools Help ",
							" Binary to C Array script help Downloading the host script To clone or download these host tools from Github go to the main page of this repository and then click Clone button to clone this repo or download as zip file This content can also be download using MCC content manager Path of the tool within the repository is tools/btl_bin_to_c_array py Setting up the Host PC The Script is compatible with Python 3 x and higher Description This script should be used to convert the binary file to a C style array containing Hex output that can be directly included in target application code It is mainly used when programming the application using the host_app_nvm application in I2C/CAN Bootloader If size of the input binary file is not aligned to device erase boundary it appends 0xFF to the binary to make it aligned and then generates the Hex output User must specify the binary file to convert (-b) hex output file (-o) and the device (-d) btl_bin_to_c_array Usage Examples Below is the syntax to show help menu for the script python harmony3_path /bootloader/tools/btl_bin_to_c_array py --help btl_bin_to_c_array_help_menu Below is the syntax and an example on how to convert the binary file to a C style array containing Hex output python harmony3_path /bootloader/tools/btl_bin_to_c_array py -b binary_file -o hex_file -d device python  harmony3_path  / bootloader / tools / btl_bin_to_c_array  py - b  harmony3_path  / bootloader_apps_i2c / apps / i2c_bootloader / test_app / firmware / sam_d20_xpro  X / dist / sam_d20_xpro / production / sam_d20_xpro  X  production  bin - o  harmony3_path  / bootloader_apps_i2c / apps / i2c_bootloader / host_app_nvm / firmware / src / test_app_images / image_pattern_hex_sam_d20_xpro  h - d samd2x ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" CAN Bootloader The CAN bootloader Library can be used to upgrade firmware on a target device without the need for an external programmer or debugger Features Supported on CORTEX-M based MCUs Uses Harmony 3 CAN PLIB to communicate resulting in smaller bootloader size Supports Fail Safe update Takes Binary File as input Receives Binary from an C Embedded Host Device Running From SRAM (For SAM Devices) Has capability to self update as it is running from SRAM bootloader_ram_layout At reset the bootloader Reset handler copies the entire bootloader firmware into SRAM from Start location and start executing from SRAM Once the application is called from bootloader applications startup code takes control over SRAM and starts executing CAN Bootloader Block Diagram can_bootloader_block_diagram Input Task: This task is responsible for receiving data from Embedded Host through the CAN interface The task keeps polling for data to be received when bootloader is in idle mode Once the packet reception is completed it gives control to Command Task Command Task: The task first validates the incoming packet from host with expected header information The task processes the commands received from Input Task and provides response back to host accordingly If the command received is a Data command it gives control to the Flash Task Flash Task: This task is responsible to program the internal flash memory with data packet received The task uses the NVM peripheral library to perform the Unlock/Erase/Write Operations ",
							" How the CAN Bootloader library works The CAN Bootloader firmware communicates with the embedded host device by using a predefined communication protocol The CAN Bootloader works in two different modes Basic Mode This mode is supported for all the devices Resides from The starting location of the flash memory region for CORTEX-M based MCUs The Bootloader performs flash erase/program/verify operations with the binary sent from host while in the firmware upgrade mode The binary sent is only of the application to be programmed Bootloader always performs flash operation from the address for (bootloader or application) binary sent from host The application can use the entire flash memory region starting from the end of bootloader space Jumps to the application once verification is completed Fail Safe Update Mode This mode is supported for the devices which have a Dual Bank flash memory Resides from the starting location of the flash memory region of both the banks on CORTEX-M based MCUs The Bootloader performs flash erase/program/verify operations with the binary sent from host while in the firmware upgrade mode Bootloader can perform flash operation in either of the banks based on the address sent by the host application The application can use only the flash memory region of one bank Performs a bank swap and reset to run the application programmed in inactive bank once verification is completed or a normal reset to run the application in current bank based on command sent from host ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" CAN Bootloader Protocol Request Packet The can bootloader protocol as shown in below figure is common for all the supported commands can_bootloader_protocol Command Indicates the command to be processed Each command is of 1 Byte width Below are the supported commands Command Type Command Code Description Unlock 0xA0 Used to calculate application start address and end address Data 0xA1 Used to send the image data Verify 0xA2 Used to verify the image data sent and programmed Reset 0xA3 Used to trigger a reset to run the application Bank Swap and reset 0xA4 Used to Swap the bank and trigger a reset to run the application Sequence Number Indicates the packet sequence number For data command the sequence number has to be incremented by 1 for every data packet Bootloader checks the sequence number once data packet is recieved If there is a mismatch it sends a sequence error response As the sequence number is of 1 Byte width once it reaches to a value of 255 it restarts from zero GUARD The Guard value must be a constant value of 0xE2 This value provides protection against spurious commands Bootloader always checks for the Guard value on packet reception and proceeds further accordingly Data Size This field indicates the number of data bytes to be received This value varies for different commands Data Contains the actual Data to be processed based on the command Length of the data to be received is indicated by Data Size field All data words must be sent in a little-endian (LSB first) format Response Codes Bootloader will send a single character response code in response to each command Sequential commands can only be sent after the response code is received for a previous command or after 100 ms timeout without a response Response Type Response Code Description OK 0x50 Command was received and processed successfully Error 0x51 There were errors during the processing of the command Invalid 0x52 Invalid command is received CRC OK 0x53 CRC verification was successful CRC Fail 0x54 CRC verification failed SEQ ERROR 0x55 Sequence number mismatch for Data command Unlock Command The Unlock Command sequence is as shown in below figure with corresponding responses can_bootloader_unlock_command Unlock command must be issued before the first Data command It is used to calculate application start address and end address This information will be used to validate if the addresses sent are within the range of flash memory Number of bytes of data to be received is 8 Bytes (Start Address + Image Size) Start Address It is the application Start Address of the flash memory It is device dependent and should be always greater than or equal to the bootloader end address It must be aligned at an Erase Unit Size boundary which is also device dependent To upgrade the bootloader itself this value must be set to 0 (For CORTEX-M based MCUs) Image size must be in increments of Erase Unit bytes which is also device dependent Data Command The Data Command sequence is as shown in below figure with corresponding responses can_bootloader_data_command Data command is used to send the image data The maximum packet length received by CAN bootloader is 64Bytes The Data size = 60Bytes as we have 4 bytes reserved for packet header Verify Command The Verify Command sequence is as shown in below figure with corresponding responses can_bootloader_verify_command Verify command is used to verify the image data sent and programmed Image CRC is a standard IEEE CRC32 with a polynomial of 0xEDB88320 Internal CRC is calculated based on the values actually read from the Flash memory after programming so it verifies the whole chain Image CRC is calculated over the previously unlocked region Reset Command The Reset Command sequence is as shown in below figure with corresponding responses can_bootloader_reset_command Reset command is used to exit the bootloader and run the application It is necessary if the host has no control over the reset pin It can also be useful even if host has control over the Reset Bank Swap and Reset Command The Bank Swap and Reset Command sequence is as shown in below figure with corresponding responses can_bootloader_BankSwap_Reset_command This command is enabled only when Fail safe update feature is selected for bootloader and the device has support for Dual Bank update Bank Swap and Reset command is used to Swap the inactive bank to active bank and trigger a reset to exit the bootloader and run the new application programmed in the inactive bank ",
							" CAN Bootloader system level execution flow Basic Bootloader system level execution flow The Bootloader code starts executing on a device Reset If there are no conditions to enter the firmware upgrade mode the Bootloader starts executing the user application Refer to Bootloader Trigger Methodsfor different conditions to enter firmware upgrade mode The Bootloader performs Flash erase/program operations while in the firmware upgrade mode basic_bootloader_execution_flow  ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" CAN Bootloader Firmware Update mode execution flow Bootloader Task Flow Bootloader task is the main task which calls the Input sub-tasks in a forever loop It calls the Input task to poll for command packets from host Once complete packet is received Input Task calls Command task to process the received command If the command received was a data command Command task calls Flash Task to flash the application can_bootloader_task_execution_flow Input Task Flow This task is used to receive the data bytes from embedded host The task keeps polling for data to be received when bootloader is in idle mode Once the packet reception is completed it gives control to Command Task can_input_task_execution_flow Command Task Flow The task first validates the incoming packet from host with expected header information The task processes the commands received from Input Task and provides response back to host accordingly If the command received is a Data command it gives control to the Flash Task can_command_task_execution_flow Flash Task Flow This task is responsible to program the internal flash memory with data packet received The task uses the NVM peripheral library to perform the Unlock/Erase/Write Operations can_flash_task_execution_flow_sam ",
							" CAN Bootloader Configurations Bootloader Specific User Configurations For devices with Dual Bank support and No Data Cache can_bootloader_mhc_config_sam For devices with No Dual Bank support and Data Cache can_bootloader_mhc_config_sam_with_cache Bootloader Peripheral Used: Specifies the communication peripheral used by bootloader to receive the application The name of the peripheral will vary from device to device Bootloader NVM Memory Used: Specifies the memory peripheral used by bootloader to perform flash operations The name of the peripheral will vary from device to device Bootloader Size (Bytes): Specifies the maximum size of flash required by the bootloader This size is calculated based on Bootloader type and Memory used This size will vary from device to device and should always be aligned to device erase unit size Enable Bootloader Trigger From Firmware: This Option can be used to Force Trigger bootloader from application firmware after a soft reset It does so by reserving the specified number of bytes in SRAM from the start of the RAM The reserved memory is updated by the application with a pre-defined pattern The bootloader firmware in the bootloader_Trigger() routine can check the reserved memory for the pre-defined pattern and enter bootloader mode if the pattern matches Number Of Bytes To Reserve From Start Of RAM: This option adds the provided offset to RAM Start address in bootloader linker script Application firmware can store some pattern in the reserved bytes region from RAM start for bootloader to check at reset in bootloader_Trigger() function Use Dual Bank For Safe Flash Update: Used to configure bootloader to use Dual banks of device to upload the application This option is visible only for devices supporting Dual flash banks Select MPU Region to configure non-cacheable memory: Used to select the MPU region for which he SRAM has been configured as non-cahceable space Configure the region selected above in MPU settings of MHC as shown in Bootloader MPU Configurations A seperate section will be created for this region in the custom linker script generated for bootloader This option is visible only for devices which have Data cache Bootloader MPU Configurations Open MPU settings from MHC- Tools option Select Enable MPU Configure the region selected in Bootloader component as ram_nocache with other parameters as shown can_bootloader_mhc_config_mpu  Bootloader Linker code for ram_nochache For CAN bootloader below xxx_message_ram section will be added to the custom linker file generated Note: xxx should be replaced with the CAN PLIB being used Example: MCAN1 MEMORY { rom ( rx )  : ORIGIN = ROM_START  LENGTH = ROM_SIZE ram ( rwx )  : ORIGIN = RAM_START  LENGTH = RAM_SIZE /* The address mentioned here should match with address mentioned in MPU settings */ ram_nocache ( RWX )  : ORIGIN =  0x2045f000  LENGTH =  ( 1    ( 11  +  1 ) )  }           mcan1_message_ram ( NOLOAD ) :  {    =  ALIGN ( 4 ) ; _s_mcan1_message_ram =   ;  * (  mcan1_message_ram )    =  ALIGN ( 4 ) ; _e_mcan1_message_ram =   ;  }   ram_nocache     CAN Bootloader will use this section to to allocate MCAN Message RAM configuration in contiguous non-cacheable buffer static uint8_t CACHE_ALIGN __attribute__ ( ( space ( data )  section ( \" mcan1_message_ram\" ) ) ) mcan1MessageRAM [ MCAN1_MESSAGE_RAM_CONFIG_SIZE ] ;  /* Set MCAN1 Message RAM Configuration */  MCAN1_MessageRAMConfigSet ( mcan1MessageRAM ) ;  Bootloader System Configurations can_bootloader_mhc_config_system Application Start Address (Hex): Start address of the application which will programmed by bootloader This value is filled by bootloader when its loaded which is equal to the bootloader size It can be modified as per user need This value will be used by bootloader to Jump to application at device reset Note For optimizing the code Bootloader component disables generation of default interrupt and exception files as shown below Enabling these interrupts explicitly may still not work as bootloader uses custom startup file which has its own Interrupt table populating only the reset handler /can_bootloader_mhc_config_interrupt_disable ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" CAN Bootloader Library Interface Name Description bootloader_Tasks Starts bootloader execution bootloader_Trigger Checks if Bootloader has to be executed at startup run_Application Runs the programmed application at startup ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Serial Memory Bootloader The Serial Memory bootloader Library can be used to upgrade firmware on a target device without the need for an external programmer or debugger Features Supported on CORTEX-M and MIPS based MCUs Uses Harmony 3 Serial Memory drivers to communicate with the associated serial memory Below are the serial memory drivers used I2C EEPROM: AT24 Driver SPI EEPROM: AT25 Driver SPI Flash: SST26 Driver QSPI Flash: SST26 Driver Serial Memory Bootloader Block Diagram serial_bootloader_block_diagram Bootloader Task Uses Serial Memory driver to reads the application binary stored in serial memory Erases the Internal Flash memory Programs the read binary into Flash memory Verifies the programed application Jumps to the Application Runs in Cooperative mode with other tasks in the system ",
							" How the Serial Memory Bootloader library works The Serial Memory Bootloader firmware communicates with the serial memory to receive application firmware Resides from The starting location of the flash memory region for CORTEX-M based MCUs The starting location of the Boot flash memory region or Program Flash memory region for MIPS based MCUs devices The Bootloader performs flash erase/program/verify operations with the binary read from serial memory while in the firmware upgrade mode The binary received is only of the application to be programmed Bootloader always performs flash operation from the address for application binary being received The application can use the entire flash memory region starting from the end of bootloader space Calls SYS_DeInitialize() before jumping to the application space Note: At first bootup either the serial memory should already have the application to be bootloaded or the application to be bootloaded has to be programmed along with bootloader using the external programmer or debugger Bootloader and Serial Memory Meta Data /* Structure to store the Meta Data of the application binary for bootloader * Note: The order of the members should not be changed */  typedef  struct  {  /* Used to Validate the Meta Data itself*/ uint32_t prologue ;  /* Flag to indicate if a firmware update is required * 0xFFFFFFFF -- Update Required Set by Serial Memory programmer after programming * the image in Serial memory * 0x00000000 -- Update Completed Changed by bootloader after programming * the image from Serial memory to internal flash */ uint32_t isAppUpdateRequired ;  /* Application Start address */ uint32_t appStartAddress ;  /* Size of the application binary */ uint32_t appSize ;  /* CRC32 value for the application binary */ uint32_t appCRC32 ;  /* Used to Validate the Meta Data itself*/ uint32_t epilogue ;  } APP_META_DATA ;  The above meta data for application has to be stored in last page of serial memory required by bootloader Bootloader reads this meta data to get details of the application binary being received and then performs the programming operation accordingly Once programming is completed it generates CRC32 on programmed space of internal flash and verifies it against the appCRC32 stored in Meta data Once verification is completed it clears the isAppUpdateRequired flag and then performs reset to jump to application serial_bootloader_meta_data ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Serial Memory Bootloader execution flow On device reset after systme initialize The Bootloader task starts executing from the SYS_Tasks() Once the Serial Memory driver is ready it retrieves the Meta Data from serial memory If any error in reading the Meta-Data it directly jumps Run application It checks if the Meta Data read is valid using the Prologue and Epilogue  If valid It stores the application start address and application size from meta data which will be used during programming operation Checks if the Update Required flag is set If set it jumps to Programming step Or continues to Trigger Check If Invalid It continues to Trigger Check Trigger Check If there are no conditions to enter the firmware upgrade mode the Bootloader jumps to Run application Refer to Bootloader Trigger Methods for different conditions to enter firmware upgrade mode Programming Starts reading the application binary from serial memory and perform erase/program operations on internal flash Once programming is completed it generates CRC32 on programmed space of internal flash and verifies it against the CRC32 value stored in Meta data Once verification is complete it clears the update required flag in meta data and triggers reset to Run application Run Application The application start address used to jump to application space can be Application start address generated during compile time Or Application start address retrieved from valid Meta Data Calls SYS_DeInitialize() function to release resources used Jumps to application space to run the updated application serial_bootloader_execution_flow ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Serial Memory Bootloader Configurations Bootloader Specific User Configurations serial_bootloader_mhc_config Bootloader Serial Memory Used: Specifies the Serial memory driver used by bootloader to receive the application The name of the serial memory will vary based on the driver connected to bootloader Bootloader NVM Memory Used: Specifies the memory peripheral used by bootloader to perform flash operations The name of the peripheral will vary from device to device Bootloader Size (Bytes): Specifies the maximum size of flash required by the bootloader This size is calculated based on Bootloader type and Memory used This size will vary from device to device and should always be aligned to device erase unit size Enable Bootloader Trigger From Firmware: This Option can be used to Force Trigger bootloader from application firmware after a soft reset It does so by reserving the specified number of bytes in SRAM from the start of the RAM The reserved memory is updated by the application with a pre-defined pattern The bootloader firmware in the bootloader_Trigger() routine can check the reserved memory for the pre-defined pattern and enter bootloader mode if the pattern matches Number Of Bytes To Reserve From Start Of RAM: This option adds the provided offset to RAM Start address in bootloader linker script Application firmware can store some pattern in the reserved bytes region from RAM start for bootloader to check at reset in bootloader_Trigger() function Bootloader System Configurations serial_bootloader_mhc_config_system Application Start Address (Hex): Start address of the application which will programmed by bootloader This value is filled by bootloader when its loaded which is equal to the bootloader size It can be modified as per user need This value will be used by bootloader to Jump to application at device reset Bootloader MPLAB X Settings As the Serial memory may not have any valid binary required by bootloader for the first time Adding the application to be bootloaded as loadable allows MPLAB X to create a unified hex file and program both these applications in their respective memory locations By doing this At first bootup bootloader directly jumps to application as the serial memory does not have any valid binary serial_bootloader_loadable  ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Serial Memory Bootloader Library Interface Name Description bootloader_Tasks Starts bootloader execution bootloader_Trigger Checks if Bootloader has to be executed at startup run_Application Runs the programmed application at startup ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" USB Device HID Bootloader The USB Device HID bootloader Library can be used to upgrade firmware on a target device without the need for an external programmer or debugger Features Supported on CORTEX-M and MIPS based MCUs Uses Harmony 3 USB Device HID driver to communicate Supports Live update Takes Normalized Hex File as input Uses Unified Host application to receive the hex file from Host PC USB Device HID Bootloader Block Diagram usb_bootloader_block_diagram The Bootloader framework is divided into 2 sub-systems Bootloader Task: Erases the Flash memory Programs the hex file records into Flash memory Computes a CRC check of the Application in Program Memory Jumps to the Application Calls the DataStream Task at end of its every state machine execution This Task routine takes an interface-agnostic approach to the actual communication medium Runs in Cooperative mode with other tasks in the system Datastream Task: This Task implements the USB Device HID communication interface to the receive the hex file from the Unified Host Application running on Host PC This Task is called from Bootloader Task routine ",
							" How the USB Device HID Bootloader library works The USB Device HID Bootloader firmware communicates with the Unified Host application running on Host PC by using a predefined communication protocol The USB Device HID Bootloader works in two different modes Basic Mode This mode is supported for all the devices Resides from The starting location of the flash memory region for CORTEX-M based MCUs The starting location of the Boot flash memory region or Program flash memory region for MIPS based MCUs devices The Bootloader performs flash erase/program/verify operations with the application hex sent from host PC using the Unified Bootloader Host Application while in the firmware upgrade mode Bootloader always performs flash operation from the address received via hex record The application can use the entire flash memory region starting from the end of bootloader space Jumps to the application once programming is completed Live Update Mode This mode is supported for the devices which have a Dual Bank flash memory Resides from The starting location of the flash memory region of both the banks on CORTEX-M based MCUs along with application code The starting location of the Program flash memory region of both the banks for MIPS based MCUs devices along with application code The Bootloader task performs flash erase/program/verify operations with the application hex sent from host PC using the Unified Bootloader Host Application in the Inactive bank Performs a bank swap and reset to run the application programmed in inactive bank on application task request ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Live Update Memory layout for CORTEX-M based MCUs Supported for the devices which have a Dual Bank flash memory Internal Flash memory is split into two equal banks Special NVM Fuse setting (AFIRST) is used to identify which bank is mapped to NVM main address space after reset Start address of Active Bank is always start of Internal Flash memory Start address of Inactive Bank is from mid of the Internal flash memory which can vary from device to device Refer to respective Data sheets for details of Flash memory layout The bootloader live update code responsible to program the inactive bank is part of the application it self Which means the programming operation can happen while the application is running Live Update Application = (Bootloader Code in Live Update mode + Application code) Having the bootloader as part of application itself avoids the overhead of memory partitioning and saves flash memory The application code is responsible to send a request to bootloader live update code to perform a bank swap and reset to run the new firmware programmed in Inactive bank arm_live_update_memory_layout ",
							" Live Update Memory layout for MIPS based MCUs Supported for the devices which have a Dual Bank flash memory Switcher code is placed at start of the Boot flash memory (0xBFC00000) as upon reset the device runs from start of boot flash memory Note: The switcher code provided does not have any programming capabilities It just performs bank swap operations Device always executes the application firmware from PFM bank mapped to lower memory region (0x1D00_0000 Physical address) Start address of Active Bank is mapped to lower region 0x9D000000 Start address of Inactive Bank is from mid of the PFM which can vary from device to device Refer to respective Data sheets for details of Flash memory layout Row size number of bytes are reserved at end of each bank for storing serial number This serial number will be used by the switcher code placed in BFM to map the appropriate PFM bank to lower memory region and run the application from there Volatile register SWAP bit is used to map either of bank to lower memory region by switcher The bootloader live update code responsible to program the inactive bank is part of the application it self Which means the programming operation can happen while the application is running Live Update Application = (Bootloader Code in Live Update mode + Application code) The application code is responsible to send a request to bootloader live update code to perform a bank swap and reset to run the new firmware programmed in Inactive bank Once this request is received the bootloader live update code performs below operation before initiating a reset to run new firmware Inactive Serial number = Active serial number + 1 At reset switcher first maps Bank 1 to lower region and reads the serial numbers from both banks If Bank 2 serial number is greater than Bank 1 serial number it maps Bank 2 to lower region by setting the Swap bit and runs the new firmware Now Bank 2 is Active bank The live update start address should always fall into lower mapped region (0x9D000000 to Mid of Flash) Size of the application in the linker script should also not exceed the Mid of flash mips_live_update_memory_layout ",
							" USB Device HID Bootloader Protocol The Unified host application running on Host-PC uses below communication protocol to interact with the Bootloader firmware The Unified host application acts as a master and issues commands to the Bootloader firmware to perform specific operations Frame Format The communication protocol follows the frame format as shown below SOH CRCL CRCH EOT Where: Represents a byte Represents an optional or variable number of bytes The frame format remains the same in both directions that is from the host application to the Bootloader and from the Bootloader to the host application The frame starts with a control character Start of Header (SOH) and ends with another control character End of Transmission (EOT) The integrity of the frame is protected by two bytes of Cyclic Redundancy Check (CRC)-16 represented by CRCL (low-byte) and CRCH (high-byte) Control Characters Some bytes in the Data field may imitate the control characters SOH and EOT The Data Link Escape (DLE) character is used to escape such bytes that could be interpreted as control characters The Bootloader always accepts the byte following a DLE as data and always sends a DLE before any of the control characters Control Hex Value Description SOH 0x01 Marks the beginning of a frame EOT 0x04 Marks the end of a frame DLE 0x10 Data link escape Commands The PC host application can issue the commands listed in below to the Bootloader The first byte in the data field carries the command Command Value in Hexadecimal Description 0x01 Read the Bootloader version information 0x02 Erase the Flash 0x03 Program the Flash 0x04 Read the CRC 0x05 Jump to the application Read Bootloader Version Information The Read Version command sequence is as shown in below table with corresponding response Request Response SOH CRCL CRCH EOT SOH 0x01 MAJOR_VER MINOR_VER CRCL CRCH EOT The Bootloader responds to the PC request for version information in two bytes as shown above MAJOR_VER = Major version of the Bootloader MINOR_VER = Minor version of the Bootloader Erase Flash The Erase Flash command sequence is as shown in below table with corresponding response Request Response SOH 0x02 CRCL CRCH EOT SOH 0x02 CRCL CRCH EOT On receiving the erase Flash command from the PC host application the Bootloader erases that entire application program space starting from the application start address configured The Bootloader Task routine returns only after entire application space is erased Program Flash The Program Flash command sequence is as shown in below table with corresponding response Request Response SOH 0x03 CRCL CRCH EOT SOH 0x03 CRCL CRCH EOT HEX_RECORD is the Intel Hex record in hexadecimal format The PC host application sends one or multiple hex records in Intel Hex format along with the program Flash command The MPLAB XC32 C/C++ Compiler generates the image in the Intel Hex format Each line in the Intel hexadecimal file represents a hexadecimal record Each hexadecimal record starts with a colon (:) and is in ASCII format The PC host application discards the colon and converts the remaining data from ASCII to hexadecimal and then sends the data to the Bootloader The Bootloader extracts the destination address and data from the hex record and writes the data into program Flash Read CRC (Currently Not Supported) The Read CRC command sequence is as shown in below table with corresponding response Request Response SOH 0x04 ADRS_LB ADRS_HB ADRS_UB ADRS_MB NUMBYTES_LB NUMBYTES_HB NUMBYTES_UB NUMBYTES_MB CRCL CRCH EOT SOH 0x04 FLASH_CRCL FLASH_CRCH CRCL CRCH EOT The read CRC command is used to verify the content of the program Flash after programming ADRS_LB ADRS_HB ADRS_UB and ADRS_MB represent the 32-bit Flash addresses from where the CRC calculation begins NUMBYTES_LB NUMBYTES_HB NUMBYTES_UB and NUMBYTES_MB represent the total number of bytes in 32-bit format for which the CRC is to be calculated Jump to Application The Jump To Application command sequence is as shown in below table with corresponding response Request Response SOH 0x05 CRCL CRCH EOT SOH 0x05 CRCL CRCH EOT The Jump to Application command from the PC host application commands the Bootloader to execute the application Once response is sent it exits the firmware upgrade mode and begins executing the application ",
							" Bootloader system level execution flow Basic Bootloader system level execution flow The Bootloader code starts executing on a device Reset If there are no conditions to enter the firmware upgrade mode the Bootloader starts executing the user application Refer to Bootloader Trigger Methods for different conditions to enter firmware upgrade mode The Bootloader performs Flash erase/program operations while in the firmware upgrade mode basic_bootloader_execution_flow Live Update Bootloader system level execution flow Supported for the devices which have a Dual Bank flash memory Cortex-M Based MCUs Special NVM Fuse setting (AFIRST) is used to identify which bank is mapped to NVM main address space after reset The bootloader live update code responsible to program the inactive bank is part of the application it self Which means the programming operation can happen while the application is running Live Update Application = (Bootloader Code in Live Update mode + Application code) The application code is responsible to send a request to bootloader live update code to perform a bank swap and reset to run the new firmware programmed in Inactive bank live_update_bootloader_execution_flow_arm MIPS Based MCUs Switcher Application in Boot flash memory is required to select the bank with latest firmware At reset switcher first maps Bank 1 to lower region and reads the serial numbers from both banks If Bank 2 serial number is greater than Bank 1 serial number it maps Bank 2 to lower region by setting the Swap bit and runs the new firmware from BANK 2 else continues to run firmware from BANK 1 The bootloader live update code responsible to program the inactive bank is part of the application it self Which means the programming operation can happen while the application is running Live Update Application = (Bootloader Code in Live Update mode + Application code) The bootloader live update code will always program the new image in the inactive bank The application code is responsible to send a request to bootloader live update code to perform a bank swap and reset to run the new firmware programmed in Inactive bank Once this request is received the bootloader live update code performs below operation before initiating a reset to run new firmware Inactive Serial number = Active serial number + 1 live_update_bootloader_execution_flow_mips ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" USB/UDP Firmware Update mode execution flow Bootloader Task Flow Erases the Flash memory Programs the hex file records into Flash memory Jumps to the Application Calls the DataStream Task at end of its every state machine execution to receive any packet from the Host PC usb_udp_bootloader_task_execution_flow usb_udp_bootloader_process_command_execution_flow DataStream Task Flow This task is used to receive data bytes from host PC and to send response to host PC It notifies the Bootloader task on completion of Data Reception or data transmit through callback usb_udp_bootloader_datastream_task_execution_flow ",
							" USB Device HID Bootloader Configurations Bootloader Specific User Configurations For Basic Bootloader images/usb_bootloader_mhc_config_basic For Live Update Bootloader usb_bootloader_mhc_config_live_update Bootloader NVM Memory Used: Specifies the memory peripheral used by bootloader to perform flash operations The name of the peripheral will vary from device to device Bootloader Size (Bytes): Specifies the maximum size of flash required by the bootloader This size is calculated based on Bootloader type and Memory used This size will vary from device to device and should always be aligned to device erase unit size Enable Bootloader Trigger From Firmware: (Basic Mode Only) This Option can be used to Force Trigger bootloader from application firmware after a soft reset It does so by reserving the specified number of bytes in SRAM from the start of the RAM The reserved memory is updated by the application with a pre-defined pattern The bootloader firmware in the bootloader_Trigger() routine can check the reserved memory for the pre-defined pattern and enter bootloader mode if the pattern matches Number Of Bytes To Reserve From Start Of RAM: This option adds the provided offset to RAM Start address in bootloader linker script Application firmware can store some pattern in the reserved bytes region from RAM start for bootloader to check at reset in bootloader_Trigger() function Use Dual Bank For Live Update: Used to configure bootloader library to use Inactive bank of the device to upload the new application This option is visible only for devices supporting Dual flash banks Live Update Flash Bank Size (Bytes): Specifies the size of bank in which both the bootloader and application code reside Thisvalue by default will be half of the available Flash memory Trigger Reset After Update: This option can be used to trigger a Swap bank and reset immediatly after programming the application in inactive bank If not enabled then the application code should call the bootloader_SwapAndReset() function to trigger Swap bank and reset USB Device HID Driver Configurations usb_bootloader_mhc_config_usb_driver Vendor ID: 0x04D8 Product Id Selection: usb_device_hid_bootloader Product ID: 0x003C To be used to configure Unified Host Application Product String Selection: USB HID Bootloader Bootloader System Configurations (Basic Mode Only) usb_bootloader_mhc_config_basic_system Application Start Address (Hex): Start address of the application which will programmed by bootloader This value is filled by bootloader when its loaded which is equal to the bootloader size It can be modified as per user need This value will be used by bootloader to Jump to application at device reset Bootloader Linker Pre Processor Macros for CORTEX-M based MCUs Based on the configurations the above linker pre processor macros will be generated in MPLAB X xc32-ld settings ROM_LENGTH specifies the size of the bootloader Basic Mode usb_bootloader_basic_linker_setting Live Update Mode usb_bootloader_live_update_linker_setting ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" USB Device HID Bootloader Library Interface Name Description bootloader_Tasks Starts bootloader execution bootloader_Trigger Checks if Bootloader has to be executed at startup run_Application Runs the programmed application at startup bootloader_SwapAndReset Updates the Serial number in Inactive Bank and triggers Reset ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" bootloader_SwapAndReset Function void  bootloader_SwapAndReset (  void  ) ; Summary Updates the Serial number in Inactive Bank and triggers Reset Description This function can be used by the application to update the serial number in inactive bank and trigger reset after Live Update is Completed Switcher in Boot Flash Memory should know the address at compile time where the serial number is stored in each bank It reads the serial number from both banks Compares the values and maps the bank with highest serial number to lower region Note: This Function will be generated only for MIPS based MCUs with dual flash bank support and when the dual bank for live update option is selected in MHC bootloader component settings Refer to Bootloader Configurations section for more details Precondition Live Update has to be completed before calling this function Parameters None Returns None Example bootloader_SwapAndReset ( ) ;  ",
							" USB Device HID Bootloader Unified Host Script Help Downloading the host script To clone or download these host tools from Github go to the main page of this repository and then click Clone button to clone this repo or download as zip file This content can also be download using MCC content manager Path of the tool within the repository is tools/UnifiedHost-*/UnifiedHost-* jar Version and Support information Refer to tools/UnifiedHost-*/readme txt for information on versions and known issues if any UART Protocol is not supported in Harmony 3 using this tool Description This host script should be used to communicate with the USB Device HID Bootloader running on the device It implements the Unified bootloader protocol required to communicate from host PC It sends the Normalized Hex File of the application to be bootloaded Configuring and Using the Unified Host tool Double click on tools/UnifiedHost-*/UnifiedHost-* jar file to launch the Host application Select the Device architecture and Protocol as shown below unified_host_device_arch Select USB Protocol Click on configure button and select the USB Device product ID Example * 3C unified_host_usb_setting Load the test application hex file to be programmed using below option unified_host_load_hex Open the Console window of the host application to view application bootloading sequence unified_host_tools_console Click on Program Device button to program the loaded test application hex file on to the device unified_host_program_device_usb Following snapshot shows output of successfully programming the test application unified_host_success_usb Using Unified Host Tool in debugging mode On Windows: Launch Windows Command prompt in tools/UnifiedHost-*/ directory Run below command to launch Unified Host Application in debugging mode java - Djava  util  logging  config  file = \"logging properties\"  - jar UnifiedHost - *  jar On Linux For running Unified Host tool in debug mode on linux make use of MPLAB X's Java JRE Launch Linux Command prompt in tools/UnifiedHost-*/ directory Run below command to launch Unified Host Application in debugging mode / opt / microchip / mplabx /  MPLAB X Version  / sys / java / zulu8  40 0 25 - ca - fx - jre8  0 222 - linux_x64 / bin / java - Djava  util  logging  config  file = \"logging properties\"  - jar UnifiedHost - *  jar Once the tool is launched refer to steps mentioned above in Configuring and Using the Unified Host tool to program application hex You can see the logs during programming sequence on the command prompt Once done you can open the tools/UnifiedHost-*/app log file and check for the programming sequence logs ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" UDP Bootloader The UDP bootloader Library can be used to upgrade firmware on a target device without the need for an external programmer or debugger Features Supported on CORTEX-M and MIPS based MCUs Uses Harmony 3 TCIP Stack to communicate Supports Live update Takes Normalized Hex File as input Uses Unified Host application to receive the hex file from Host PC UDP Bootloader Block Diagram udp_bootloader_block_diagram The Bootloader framework is divided into 2 sub-systems Bootloader Task: Erases the Flash memory Programs the hex file records into Flash memory Computes a CRC check of the Application in Program Memory Jumps to the Application Calls the DataStream Task at end of its every state machine execution This Task routine takes an interface-agnostic approach to the actual communication medium Runs in Cooperative mode with other tasks in the system Datastream Task: This Task implements the UDP communication interface to the receive the hex file from the Unified Host Application running on Host PC This Task is called from Bootloader Task routine ",
							" How the UDP Bootloader library works The UDP Bootloader firmware communicates with the Unified Host application running on Host PC by using a predefined communication protocol The UDP Bootloader works in two different modes Basic Mode This mode is supported for all the devices Resides from The starting location of the flash memory region for CORTEX-M based MCUs The starting location of the Boot flash memory region or Program flash memory region for MIPS based MCUs devices The Bootloader performs flash erase/program/verify operations with the application hex sent from host PC using the Unified Bootloader Host Application while in the firmware upgrade mode Bootloader always performs flash operation from the address received via hex record The application can use the entire flash memory region starting from the end of bootloader space Jumps to the application once programming is completed Live Update Mode This mode is supported for the devices which have a Dual Bank flash memory Resides from The starting location of the flash memory region of both the banks on CORTEX-M based MCUs along with application code The starting location of the Program flash memory region of both the banks for MIPS based MCUs devices along with application code The Bootloader task performs flash erase/program/verify operations with the application hex sent from host PC using the Unified Bootloader Host Application in the Inactive bank Performs a bank swap and reset to run the application programmed in inactive bank on application task request ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" UDP Bootloader Protocol The Unified host application running on Host-PC uses below communication protocol to interact with the Bootloader firmware The Unified host application acts as a master and issues commands to the Bootloader firmware to perform specific operations Frame Format The communication protocol follows the frame format as shown below SOH CRCL CRCH EOT Where: Represents a byte Represents an optional or variable number of bytes The frame format remains the same in both directions that is from the host application to the Bootloader and from the Bootloader to the host application The frame starts with a control character Start of Header (SOH) and ends with another control character End of Transmission (EOT) The integrity of the frame is protected by two bytes of Cyclic Redundancy Check (CRC)-16 represented by CRCL (low-byte) and CRCH (high-byte) Control Characters Some bytes in the Data field may imitate the control characters SOH and EOT The Data Link Escape (DLE) character is used to escape such bytes that could be interpreted as control characters The Bootloader always accepts the byte following a DLE as data and always sends a DLE before any of the control characters Control Hex Value Description SOH 0x01 Marks the beginning of a frame EOT 0x04 Marks the end of a frame DLE 0x10 Data link escape Commands The PC host application can issue the commands listed in below to the Bootloader The first byte in the data field carries the command Command Value in Hexadecimal Description 0x01 Read the Bootloader version information 0x02 Erase the Flash 0x03 Program the Flash 0x04 Read the CRC 0x05 Jump to the application Read Bootloader Version Information The Read Version command sequence is as shown in below table with corresponding response Request Response SOH CRCL CRCH EOT SOH 0x01 MAJOR_VER MINOR_VER CRCL CRCH EOT The Bootloader responds to the PC request for version information in two bytes as shown above MAJOR_VER = Major version of the Bootloader MINOR_VER = Minor version of the Bootloader Erase Flash The Erase Flash command sequence is as shown in below table with corresponding response Request Response SOH 0x02 CRCL CRCH EOT SOH 0x02 CRCL CRCH EOT On receiving the erase Flash command from the PC host application the Bootloader erases that entire application program space starting from the application start address configured The Bootloader Task routine returns only after entire application space is erased Program Flash The Program Flash command sequence is as shown in below table with corresponding response Request Response SOH 0x03 CRCL CRCH EOT SOH 0x03 CRCL CRCH EOT HEX_RECORD is the Intel Hex record in hexadecimal format The PC host application sends one or multiple hex records in Intel Hex format along with the program Flash command The MPLAB XC32 C/C++ Compiler generates the image in the Intel Hex format Each line in the Intel hexadecimal file represents a hexadecimal record Each hexadecimal record starts with a colon (:) and is in ASCII format The PC host application discards the colon and converts the remaining data from ASCII to hexadecimal and then sends the data to the Bootloader The Bootloader extracts the destination address and data from the hex record and writes the data into program Flash ",
							" Read CRC (Currently Not Supported) The Read CRC command sequence is as shown in below table with corresponding response Request Response SOH 0x04 ADRS_LB ADRS_HB ADRS_UB ADRS_MB NUMBYTES_LB NUMBYTES_HB NUMBYTES_UB NUMBYTES_MB CRCL CRCH EOT SOH 0x04 FLASH_CRCL FLASH_CRCH CRCL CRCH EOT The read CRC command is used to verify the content of the program Flash after programming ADRS_LB ADRS_HB ADRS_UB and ADRS_MB represent the 32-bit Flash addresses from where the CRC calculation begins NUMBYTES_LB NUMBYTES_HB NUMBYTES_UB and NUMBYTES_MB represent the total number of bytes in 32-bit format for which the CRC is to be calculated ",
							" Jump to Application The Jump To Application command sequence is as shown in below table with corresponding response Request Response SOH 0x05 CRCL CRCH EOT SOH 0x05 CRCL CRCH EOT The Jump to Application command from the PC host application commands the Bootloader to execute the application Once response is sent it exits the firmware upgrade mode and begins executing the application ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" UDP Bootloader Configurations Bootloader Specific User Configurations For Basic Bootloader udp_bootloader_mhc_config_basic For Live Update Bootloader udp_bootloader_mhc_config_live_update Bootloader NVM Memory Used: Specifies the memory peripheral used by bootloader to perform flash operations The name of the peripheral will vary from device to device Bootloader Size (Bytes): Specifies the maximum size of flash required by the bootloader This size is calculated based on Bootloader type and Memory used This size will vary from device to device and should always be aligned to device erase unit size Enable Bootloader Trigger From Firmware: (Basic Mode Only) This Option can be used to Force Trigger bootloader from application firmware after a soft reset It does so by reserving the specified number of bytes in SRAM from the start of the RAM The reserved memory is updated by the application with a pre-defined pattern The bootloader firmware in the bootloader_Trigger() routine can check the reserved memory for the pre-defined pattern and enter bootloader mode if the pattern matches Number Of Bytes To Reserve From Start Of RAM: This option adds the provided offset to RAM Start address in bootloader linker script Application firmware can store some pattern in the reserved bytes region from RAM start for bootloader to check at reset in bootloader_Trigger() function Bootloader UDP Port Number: Port number to be used to communicate via Unified Host Application Use Dual Bank For Live Update: Used to configure bootloader library to use Inactive bank of the device to upload the new application This option is visible only for devices supporting Dual flash banks Live Update Flash Bank Size (Bytes): Specifies the size of bank in which both the bootloader and application code reside Thisvalue by default will be half of the available Flash memory Trigger Reset After Update: This option can be used to trigger a Swap bank and reset immediatly after programming the application in inactive bank If not enabled then the application code should call the bootloader_SwapAndReset() function to trigger Swap bank and reset UDP Configurations udp_bootloader_mhc_config_udp_stack IPv4 Static Address: 102 168 1 11 To be used to configure Unified Host Application IPv4 SubNet Mask: 255 255 255 0 IPv4 Default Gateway Address: 102 168 1 11 IPv4 Primary DNS: 102 168 1 11 Bootloader System Configurations (Basic Mode Only) /udp_bootloader_mhc_config_basic_system Application Start Address (Hex): Start address of the application which will programmed by bootloader This value is filled by bootloader when its loaded which is equal to the bootloader size It can be modified as per user need This value will be used by bootloader to Jump to application at device reset Bootloader Linker Pre Processor Macros for CORTEX-M based MCUs Based on the configurations the above linker pre processor macros will be generated in MPLAB X xc32-ld settings ROM_LENGTH specifies the size of the bootloader Basic Mode udp_bootloader_basic_linker_setting Live Update Mode udp_bootloader_live_update_linker_setting ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" UDP Bootloader Library Interface Name Description bootloader_Tasks Starts bootloader execution bootloader_Trigger Checks if Bootloader has to be executed at startup run_Application Runs the programmed application at startup bootloader_SwapAndReset Updates the Serial number in Inactive Bank and triggers Reset ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" UDP Bootloader Unified Host Script Help Downloading the host script To clone or download these host tools from Github go to the main page of this repository and then click Clone button to clone this repo or download as zip file This content can also be download using MCC content manager Path of the tool within the repository is tools/UnifiedHost-*/UnifiedHost-* jar Version and Support information Refer to tools/UnifiedHost-*/readme txt for information on versions and known issues if any UART Protocol is not supported in Harmony 3 using this tool Description This host script should be used to communicate with the USB Device HID Bootloader running on the device It implements the Unified bootloader protocol required to communicate from host PC It sends the Normalized Hex File of the application to be bootloaded Configuring and Using the Unified Host tool Configure the Host PC for setting up IP Address to communicate with the device Go to Control Panel/Network and Internet/Network Connections Open Ethernet properties udp_host_pc_ethernet_properties - Double Click on **Internet Protocol Version 4 (TCP/IPv4)** udp_host_pc_ipv4_click  - Configure the IP Address as shown below - **IP address : 192 168 1 12** - **Subnet Mask : 255 255 255 0** udp_host_pc_ip_address Double click on tools/UnifiedHost-*/UnifiedHost-* jar file to launch the Host application Select the Device architecture and Protocol as shown below unified_host_device_arch Select UDP Protocol Click on configure button to configure UDP port Number and IP Address unified_host_udp_setting Load the test application hex file to be programmed using below option unified_host_load_hex Open the Console window of the host application to view application bootloading sequence unified_host_tools_console Click on Program Device button to program the loaded test application hex file on to the device unified_host_program_device_udp Following snapshot shows output of successfully programming the test application unified_host_success_udp Using Unified Host Tool in debugging mode On Windows: Launch Windows Command prompt in tools/UnifiedHost-*/ directory Run below command to launch Unified Host Application in debugging mode java - Djava  util  logging  config  file = \"logging properties\"  - jar UnifiedHost - *  jar On Linux For running Unified Host tool in debug mode on linux make use of MPLAB X's Java JRE Launch Linux Command prompt in tools/UnifiedHost-*/ directory Run below command to launch Unified Host Application in debugging mode / opt / microchip / mplabx /  MPLAB X Version  / sys / java / zulu8  40 0 25 - ca - fx - jre8  0 222 - linux_x64 / bin / java - Djava  util  logging  config  file = \"logging properties\"  - jar UnifiedHost - *  jar Once the tool is launched refer to steps mentioned above in Configuring and Using the Unified Host tool to program application hex You can see the logs during programming sequence on the command prompt Once done you can open the tools/UnifiedHost-*/app log file and check for the programming sequence logs ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" File System Bootloader The File System bootloader library can be used to upgrade firmware on a target device without the need for an external programmer or debugger Features Supported on CORTEX-M and MIPS based MCUs Uses Harmony 3 File System Service to communicate with underlying media Takes Binary File as input File System Bootloader Block Diagram fs_bootloader_block_diagram Bootloader Task Uses File System Service to read the Binary file from the media Erases the Flash memory Programs the binary into Flash memory Jumps to the Application Runs in Cooperative mode with other tasks in the system Supported Medias: USB Host MSD SDCARD Serial Memory I2C EEPROM SPI EEPROM SPI Flash QSPI Flash ",
							" How the File System Bootloader library works The File System Bootloader firmware uses the File System API's to communicates with the underlying Media The File System Bootloader works in two different modes Bootloader resides from The starting location of the flash memory region for CORTEX-M based MCUs The starting location of the Boot flash memory region or Program flash memory region for MIPS based MCUs devices The Bootloader performs flash erase/program operations with the application binary received from the media in the firmware upgrade mode Bootloader always performs flash operation from the application start address used during compile time The application can use the entire flash memory region starting from the end of bootloader space Jumps to the application once programming is completed ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" File System Bootloader system level execution flow The Bootloader code starts executing on a device Reset If there are no conditions to enter the firmware upgrade mode the Bootloader starts executing the user application Refer to Bootloader Trigger Methods for different conditions to enter firmware upgrade mode The Bootloader performs Flash erase/program operations while in the firmware upgrade mode basic_bootloader_execution_flow ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" File System Bootloader Firmware Update mode execution flow Bootloader Task Flow Erases the Flash memory Programs the binary into Flash memory Jumps to the Application USB Host MSD Bootloader Task Flow fs_usb_msd_bootloader_task_execution_flow SD Card and Serial Memory Bootloader Task Flow fs_sdcard_serial_bootloader_task_execution_flow ",
							" USB Host MSD Bootloader Configurations Bootloader Specific User Configurations fs_bootloader_mhc_config_usb Bootloader Media Type: Change the Media Type to USB Mass Storage Device Bootloader NVM Memory Used: Specifies the memory peripheral used by bootloader to perform flash operations The name of the peripheral will vary from device to device Bootloader Size (Bytes): Specifies the maximum size of flash required by the bootloader This size is calculated based on Bootloader type and Memory used This size will vary from device to device and should always be aligned to device erase unit size Enable Bootloader Trigger From Firmware: This Option can be used to Force Trigger bootloader from application firmware after a soft reset It does so by reserving the specified number of bytes in SRAM from the start of the RAM The reserved memory is updated by the application with a pre-defined pattern The bootloader firmware in the bootloader_Trigger() routine can check the reserved memory for the pre-defined pattern and enter bootloader mode if the pattern matches Number Of Bytes To Reserve From Start Of RAM: This option adds the provided offset to RAM Start address in bootloader linker script Application firmware can store some pattern in the reserved bytes region from RAM start for bootloader to check at reset in bootloader_Trigger() function Application Binary Image Path: Application binary image file name with path If only file name is mentioned bootloader will try to open the file from the root directory Default: image bin Can be used to specify custom paths based on requirement Example: dir1/dir2/app bin File System Configurations fs_bootloader_mhc_config_usb_fs Use File System Auto Mount Feature: Enabled by default when File System Bootloader is added Media Type: Change the Media Type to SYS_FS_MEDIA_TYPE_MSD Make FAT File System Read-only: Enabled by default when File System Bootloader is added as there are no write operations to be done Enabling this option also saves significant amount of flash memory Bootloader System Configurations fs_bootloader_mhc_config_usb_system Application Start Address (Hex): Start address of the application which will programmed by bootloader This value is filled by bootloader when its loaded which is equal to the bootloader size It can be modified as per user need This value will be used by bootloader to Jump to application at device reset Bootloader Linker Pre Processor Macros for CORTEX-M based MCUs Based on the configurations the above linker pre processor macros will be generated in MPLAB X xc32-ld settings ROM_LENGTH specifies the size of the bootloader fs_bootloader_usb_linker_setting ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" SD Card Bootloader Configurations Bootloader Specific User Configurations fs_bootloader_mhc_config_sdcard Bootloader Media Type: Change the Media Type to SDCARD Bootloader NVM Memory Used: Specifies the memory peripheral used by bootloader to perform flash operations The name of the peripheral will vary from device to device Bootloader Size (Bytes): Specifies the maximum size of flash required by the bootloader This size is calculated based on Bootloader type and Memory used This size will vary from device to device and should always be aligned to device erase unit size Enable Bootloader Trigger From Firmware: This Option can be used to Force Trigger bootloader from application firmware after a soft reset It does so by reserving the specified number of bytes in SRAM from the start of the RAM The reserved memory is updated by the application with a pre-defined pattern The bootloader firmware in the bootloader_Trigger() routine can check the reserved memory for the pre-defined pattern and enter bootloader mode if the pattern matches Number Of Bytes To Reserve From Start Of RAM: This option adds the provided offset to RAM Start address in bootloader linker script Application firmware can store some pattern in the reserved bytes region from RAM start for bootloader to check at reset in bootloader_Trigger() function Application Binary Image Path: Application binary image file name with path If only file name is mentioned bootloader will try to open the file from the root directory Default: image bin Can be used to specify custom paths based on requirement Example: dir1/dir2/app bin File System Configurations fs_bootloader_mhc_config_sdcard_fs Use File System Auto Mount Feature: Enabled by default when File System Bootloader is added Media Type: Change the Media Type to SYS_FS_MEDIA_TYPE_SDCARD Make FAT File System Read-only: Enabled by default when File System Bootloader is added as there are no write operations to be done Enabling this option also saves significant amount of flash memory Bootloader System Configurations fs_bootloader_mhc_config_sdcard_system Application Start Address (Hex): Start address of the application which will programmed by bootloader This value is filled by bootloader when its loaded which is equal to the bootloader size It can be modified as per user need This value will be used by bootloader to Jump to application at device reset Bootloader Linker Pre Processor Macros for CORTEX-M based MCUs Based on the configurations the above linker pre processor macros will be generated in MPLAB X xc32-ld settings ROM_LENGTH specifies the size of the bootloader fs_bootloader_sdcard_linker_setting ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Bootloader Sizing And Considerations Bootloader Sizes The example Bootloaders provided have XC32 optimization settings to -O2 However in terms of size this option does not produce the most optimal code Turning on the -Os will reduce the size of the Bootloader Note: By default the bootloader size will be rounded off to the nearest erase unit size of the device Size change considerations It must be ensured that the user applications memory region does not overlap with the memory region reserved for the Bootloader The Bootloader generated by MHC should be considered a starting point for your products Bootloader As such adding new features may cause the Bootloader to exceed the default size calculated If the size of the Bootloader changes the following steps should be performed to adjust both the Bootloader and the application in order to make sure that both fit and make best use of the device memory Increase the Bootloader Size in Bootloader MHC config menu to some approximate value and regenerate the code Determine the new ending address of the Bootloader This can be done by using either the map file generated by MPLAB X IDE with the respective Compiler or by using the ELFViewer plug-in for MPLAB X IDE Round the size from the map file to the nearest ERASE unit size value Enter the new value again in Bootloader Size in Bootloader MHC config menu Change the Application start Address from system settings in both Bootloader and application projects accordingly if it is falling inside bootloader region Recompile both the Bootloader and the application If only the Application start address needs to be modified for application then perform following steps: Change the Application start Address from system settings in both Bootloader and application projects accordingly Recompile both the Bootloader and the application ",
							" Serial Memory Bootloader Configurations Bootloader Specific User Configurations fs_bootloader_mhc_config_serial Bootloader Media Type: Change the Media Type to Serial Memory Bootloader NVM Memory Used: Specifies the memory peripheral used by bootloader to perform flash operations The name of the peripheral will vary from device to device Bootloader Size (Bytes): Specifies the maximum size of flash required by the bootloader This size is calculated based on Bootloader type and Memory used This size will vary from device to device and should always be aligned to device erase unit size Enable Bootloader Trigger From Firmware: This Option can be used to Force Trigger bootloader from application firmware after a soft reset It does so by reserving the specified number of bytes in SRAM from the start of the RAM The reserved memory is updated by the application with a pre-defined pattern The bootloader firmware in the bootloader_Trigger() routine can check the reserved memory for the pre-defined pattern and enter bootloader mode if the pattern matches Number Of Bytes To Reserve From Start Of RAM: This option adds the provided offset to RAM Start address in bootloader linker script Application firmware can store some pattern in the reserved bytes region from RAM start for bootloader to check at reset in bootloader_Trigger() function Application Binary Image Path: Application binary image file name with path If only file name is mentioned bootloader will try to open the file from the root directory Default: image bin Can be used to specify custom paths based on requirement Example: dir1/dir2/app bin File System Configurations fs_bootloader_mhc_config_serial_fs Use File System Auto Mount Feature: Enabled by default when File System Bootloader is added Media Type: Change the Media Type to SYS_FS_MEDIA_TYPE_SPIFLASH Make FAT File System Read-only: Enabled by default when File System Bootloader is added as there are no write operations to be done Enabling this option also saves significant amount of flash memory Bootloader System Configurations fs_bootloader_mhc_config_serial_system Application Start Address (Hex): Start address of the application which will programmed by bootloader This value is filled by bootloader when its loaded which is equal to the bootloader size It can be modified as per user need This value will be used by bootloader to Jump to application at device reset Bootloader Linker Pre Processor Macros for CORTEX-M based MCUs Based on the configurations the above linker pre processor macros will be generated in MPLAB X xc32-ld settings ROM_LENGTH specifies the size of the bootloader fs_bootloader_serial_linker_setting ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Bootloader Sizing And Considerations Bootloader Sizes The example Bootloaders provided have XC32 optimization settings to -O2 However in terms of size this option does not produce the most optimal code Turning on the -Os will reduce the size of the Bootloader Note: By default the bootloader size will be rounded off to the nearest erase unit size of the device Size change considerations It must be ensured that the user applications memory region does not overlap with the memory region reserved for the Bootloader The Bootloader generated by MHC should be considered a starting point for your products Bootloader As such adding new features may cause the Bootloader to exceed the default size calculated If the size of the Bootloader changes the following steps should be performed to adjust both the Bootloader and the application in order to make sure that both fit and make best use of the device memory Increase the Bootloader Size in Bootloader MHC config menu to some approximate value and regenerate the code Determine the new ending address of the Bootloader This can be done by using either the map file generated by MPLAB X IDE with the respective Compiler or by using the ELFViewer plug-in for MPLAB X IDE Round the size from the map file to the nearest ERASE unit size value Enter the new value again in Bootloader Size in Bootloader MHC config menu Change the Application start Address from system settings in both Bootloader and application projects accordingly if it is falling inside bootloader region Recompile both the Bootloader and the application If only the Application start address needs to be modified for application then perform following steps: Change the Application start Address from system settings in both Bootloader and application projects accordingly Recompile both the Bootloader and the application ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" File System Bootloader Library Interface Name Description bootloader_Tasks Starts bootloader execution bootloader_Trigger Checks if Bootloader has to be executed at startup run_Application Runs the programmed application at startup ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout ",
							" Basic Memory layout for CORTEX-M based MCUs The placement of the Bootloader and the application in flash memory should be such that the application will not overwrite the Bootloader and the Bootloader can properly program the application when it is downloaded Bootloader code is always placed at start of the flash address The application code can be placed anywhere after the bootloader end address The application start address should be aligned to Erase Unit Size of the device As the Bootloader code requires the application start address to be mentioned at compile time it should match in both the application and bootloader Note: The start address and the end address of the Bootloader and the application will vary for different devices Refer to respective Data sheets for details of Flash memory layout arm_basic_memory_layout "];

